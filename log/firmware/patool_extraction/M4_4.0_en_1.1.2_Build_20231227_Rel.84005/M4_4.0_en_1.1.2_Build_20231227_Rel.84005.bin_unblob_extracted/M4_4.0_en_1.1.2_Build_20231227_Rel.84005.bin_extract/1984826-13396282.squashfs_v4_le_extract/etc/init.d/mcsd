#!/bin/sh /etc/rc.common
# Copyright (c) 2013-2016 Qualcomm Atheros, Inc.
# All Rights Reserved.
# Qualcomm Atheros Confidential and Proprietary.

START=75
USE_PROCD=1
RESPAWN_THRESHOLD=120
RESPAWN_TIMEOUT=5
RESPAWN_RETRIES=10

SERVICE_WRITE_PID=1
SERVICE_DAEMONIZE=1
SERVICE_STOP_TIME=1
SERVICE_PATH="/usr/sbin/mcsd"
MCSD_CONFIG_FILE="/tmp/mcs.conf"
MCSD_RESTART_PID="/tmp/.mcs.restart.pid"
MCSD_RESTART_LOCK="/tmp/.mcs.restart.lock"
MCSD_VID_FILE="/tmp/mcs_vid_file"

BR_DEVICE=
WLAN_DEVICES=
WLAN_DEV_READY=
WLAN_DEV_NOT_READY=
ETHER_DEVICES=
PLC_DEVICE=
ALL_DEVICES=
MANAGED_INF_NUM=0
WLAN_VLAN_DEVICES=
WLAN_VLAN_NUM=0

local backhaul_network="backhaul"

mcs_cfg_append() {
	echo "$1" >> "$MCSD_CONFIG_FILE"
}


__mcs_iterate_networks() {
	local config="$1"
	local type br_device

	[ -n "$BR_DEVICE" ] && return

	config_get type "$config" type
	[ -z "$type" -o ! "$type" = "bridge" ] && return

	BR_DEVICE="$config"
}


mcs_get_bridge_iface() {
	BR_DEVICE=""

	#config_load network
	#config_foreach __mcs_iterate_networks interface
	config_load 'mcsd'  
	config_get BR_DEVICE config 'BridgeInterface' 'lan'	
    
	
	eval "$1='$BR_DEVICE'"
}

__mcs_get_switch_iface() {
	local loc_switch_iface="auto"
	local implicit_vlan="0"
	local ref_design

	config_load mcsd
	config_get loc_switch_iface config SwitchInterface ""
	if [ -z "$loc_switch_iface" ]; then
		eval "$1=''"
		return
	fi

	if [ "$loc_switch_iface" = "auto" ]; then
		ref_design=`cat /tmp/sysinfo/board_name`

		# List of supported reference designs. For other designs
		# either add to cases, or setup SwitchInterface.
		case "$ref_design" in
		ap148|ap145|db149)
		# S17c switch
			loc_switch_iface="eth1"
			;;
		ap-dk01*|ap-dk04*)
			loc_switch_iface="eth1"
			implicit_vlan="1"
			;;
		ap135)
		# ap135 has S17 switch, which is not fully supported by
		# the multicast switch wrapper. Disable it for now until
		# support for S17 will be added.
			loc_switch_iface=""
			;;
		*)
			loc_switch_iface=""
			;;
		esac
	fi

	local loc_switch_cpu_port
	mcs_get_switch_cpu_port loc_switch_cpu_port

	local lan_vid
	mcs_get_switch_lan_vid lan_vid

	if [ -z "$switch_cpu_port_tagged" -o "$implicit_vlan" = "1" ]; then
		eval "$1='$loc_switch_iface'"
	else
		eval "$1='${loc_switch_iface}.${lan_vid}'"
	fi
}

mcs_get_switch_lan_vid() {
	local loc_lan_vid

	config_load mcsd
	config_get loc_lan_vid config SwitchLanVid ""

	eval "$1='$loc_lan_vid'"
}

__mcs_get_switch_cpu_port_iterate() {
	config_get vlan "$1" "vlan"
	config_get ports "$1" "ports"

	if [ "${vlan}" = "$2" ]; then
		switch_cpu_port=`echo ${ports} |sed 's/t//g' |cut -f 1 -d " "`
		switch_cpu_port_tagged=`echo ${ports} |grep t`
	fi
}

mcs_get_switch_cpu_port() {
	local lan_vid
	mcs_get_switch_lan_vid lan_vid

	config_load network
	config_foreach __mcs_get_switch_cpu_port_iterate switch_vlan $lan_vid

	eval "$1='$switch_cpu_port'"
}

__mcs_get_plc_iface() {
	local plciface iface interface
	local br_device="$1"

	config_load plc
	config_get plciface config PlcIfname

	[ -z "$plciface" ] && return

	config_load network
	#config_get ifnames $br_device device
	config_get ifnames $br_device plcIfs	

	for iface in $ifnames; do
        interface=`echo "$iface" | cut -d '.' -f1`
		if [ "$interface" = "$plciface" ]; then
			PLC_DEVICE=${iface}:PLC
			MANAGED_INF_NUM=$((MANAGED_INF_NUM + 1))
			return
		fi
	done
}

# mcs_get_plc_iface()
# input: $1 bridge interface
mcs_get_plc_iface() {
	local br_device="$1"

	PLC_DEVICE=""

	__mcs_get_plc_iface $br_device
}


__mcs_get_wlan_ifaces() {
	local config="$1"
	local iface network disabled device devtype

	config_get iface "$config" vapname
	config_get network "$config" network
	config_get device "$config" device
	config_get devtype  "$device" type ''
	config_get disabled "$config" disabled '0'

	if [ "$2" = "$network" -a "$disabled" -eq 0 ]; then
		if [ -n "$iface" ]; then
			if [ "$devtype" = "ralinkwifi" ]; then
				WLAN_DEVICES="${WLAN_DEVICES}${WLAN_DEVICES:+","}${iface}:WLAN"
			else
				WLAN_DEVICES="${WLAN_DEVICES}${WLAN_DEVICES:+","}${iface}:~WLAN"
			fi
			WLAN_DEV_READY=$((WLAN_DEV_READY +1))
		else
			WLAN_DEV_NOT_READY=$((WLAN_DEV_NOT_READY +1))
		fi
	fi
}

# mcs_get_wlan_ifaces()
# input: $1 bridge interface
# output: $2 List of all WLAN interfaces bound to the bridge
mcs_get_wlan_ifaces() {
	local br_device="$1"

	WLAN_DEVICES=""
	WLAN_DEV_READY=0
	WLAN_DEV_NOT_READY=0
	config_load wireless
	config_foreach __mcs_get_wlan_ifaces wifi-iface $br_device

	eval "$2='${WLAN_DEVICES}'"
}

__mcs_is_vlan_iface() {
    local iface="$1"

    echo "$iface" | grep '\.' >/dev/null 2>&1
    if [ "$?" -eq "0" ]; then
        return 0
    fi

    return 1
}

__mcs_iterate_wlan_ifaces() {
    local config="$1"
    local iface network disabled
    local interface

    config_get iface "$config" ifname
    config_get network "$config" network
    config_get disabled "$config" disabled '0'

    if [ -n "$iface" -a "$backhaul_network" = "$network" -a "$disabled" -eq 0 ]; then
        interface=`echo "$2" | cut -d '.' -f1`
        if [ "$interface" = "$iface" ]; then
            eval "$3='0'"
            eval "$4=$config"
        fi
    fi
}

__mcs_is_device_wlan() {
    local iface="$1"
    device_wlan=1

    if [ -n "$backhaul_network" ]; then
        config_load wireless
        config_foreach __mcs_iterate_wlan_ifaces wifi-iface $iface device_wlan iface_config
    fi

    return $device_wlan
}

__mcs_get_wlan_vlan_ifaces() {
    local config="$1"
    local ifnames bridge_name is5g

    

    if [ "$2" = "$config" ]; then
                #initially VLAN interfaces are added using vconfig and brctl tool 
                #to avoid multiple restarts.VLAN interfaces added this way are not 
                #detected by config_get, so using direct command here.
        config_get ifnames "$1" vlanifs
        for iface in $ifnames; do
            if __mcs_is_vlan_iface $iface; then
                if __mcs_is_device_wlan $iface; then
                    WLAN_VLAN_DEVICES="${WLAN_VLAN_DEVICES}${WLAN_VLAN_DEVICES:+","}${iface}:WLAN_VLAN"
                    WLAN_VLAN_NUM=$((WLAN_VLAN_NUM +1))
                fi
            fi
        done
    fi
}

mcs_get_wlan_vlan_ifaces() {
    local br_device="$1"

    WLAN_VLAN_DEVICES=""
    WLAN_VLAN_NUM=0

    config_load repacd
    config_get traffic_separation_enabled repacd TrafficSeparationEnabled '0'
    config_get traffic_separation_active repacd TrafficSeparationActive '0'
    config_get backhaul_network repacd NetworkBackhaul 'backhaul'
    if [ "$traffic_separation_enabled" -gt 0 ] && \
        [ "$traffic_separation_active" -gt 0 ]; then
        config_load network
        config_foreach __mcs_get_wlan_vlan_ifaces interface $br_device
    fi

    eval "$2='${WLAN_VLAN_DEVICES}'"

}


__mcs_get_ether_ifaces() {
	local config="$1"
	local ifnames network plciface
	local guest_eth_vid
	local eth_if
	sgmac_support=$(uci get profile.switch.sgmac -c /etc/profile.d)
	eth_if=$(uci -c /etc/profile.d get profile.@DEVINFO[0].eth_root)
	
	#config_get ifnames "$config" device
	ifnames=`uci get "network.lan.ifname"`

	config_load plc
	config_get plciface config PlcIfname

    config_load wifi
    config_get guest_eth_vid guest vlan_id
    
	local switch_iface
	__mcs_get_switch_iface switch_iface

	if [ "$2" = "$config" ]; then
	   for iface in $ifnames; do
		   [ "$iface" = "$plciface" ] && continue
		if [ "$iface" = "$switch_iface" ]; then
			ETHER_DEVICES="${ETHER_DEVICES}${ETHER_DEVICES:+","}${iface}:ESWITCH"
			MANAGED_INF_NUM=$((MANAGED_INF_NUM + 1))
		else
			ETHER_DEVICES="${ETHER_DEVICES}${ETHER_DEVICES:+","}${iface}:ETHER"
            MANAGED_INF_NUM=$((MANAGED_INF_NUM + 1))
            if [ -n "$guest_eth_vid" -a "$guest_eth_vid" != 0 ]; then
				if [ "${sgmac_support}" != "yes"  ]; then
					ETHER_DEVICES="${ETHER_DEVICES}${ETHER_DEVICES:+","}${iface}${iface:+"."}${guest_eth_vid}:ETHER"
					MANAGED_INF_NUM=$((MANAGED_INF_NUM + 1))
				fi
            fi
		fi
	   done
	   
		if [ -n "$sgmac_support" -a "$sgmac_support" == "yes" ]; then
			if [ -n "$guest_eth_vid" -a "$guest_eth_vid" != 0 ]; then
				ETHER_DEVICES="${ETHER_DEVICES}${ETHER_DEVICES:+","}${eth_if}${eth_if:+"."}${guest_eth_vid}:ETHER"
                MANAGED_INF_NUM=$((MANAGED_INF_NUM + 1))
            fi
		fi
	fi
}

# mcs_get_ether_ifaces()
# input: $1 bridge interface
# output: $2 List of all Ethernet interfaces bound to the bridge
mcs_get_ether_ifaces() {
	local br_device="$1"

	ETHER_DEVICES=""
	config_load network
	config_foreach __mcs_get_ether_ifaces interface $br_device

	eval "$2='${ETHER_DEVICES}'"
}

# mcs_get_ifaces()
# input: $1 bridge interface
# output: $2 List of ALL interface bound to the bridge
mcs_get_ifaces() {
	local br_device="$1"
	local retry=0

	WLAN_DEVICES=""
	WLAN_DEV_READY=0
	WLAN_DEV_NOT_READY=0
	ETHER_DEVICES=""
	PLC_DEVICE=""
	WLAN_VLAN_DEVICES=""
	WLAN_VLAN_NUM=0

	config_load network
	config_foreach __mcs_get_ether_ifaces interface $br_device

	mcs_get_plc_iface $br_device

	config_load wireless
	config_foreach __mcs_get_wlan_ifaces wifi-iface $br_device
	
	config_load network
	config_foreach __mcs_get_wlan_vlan_ifaces interface $br_device	

	#while [ "$WLAN_DEV_NOT_READY" -gt 0 ]; do
	#	retry=$((retry +1))
	#	if [ "$retry" -gt 5 ]; then
	#		echo "WLAN $WLAN_DEV_NOT_READY interfaces not ready, failed" >/dev/console
	#		break
	#	fi
	#	sleep 2

	#	WLAN_DEVICES=""
	#	WLAN_DEV_READY=0
	#	WLAN_DEV_NOT_READY=0
	#	config_load wireless
	#	config_foreach __mcs_get_wlan_ifaces wifi-iface $br_device
	#done
	

	ALL_DEVICES=$WLAN_DEVICES
	if [ -n "$WLAN_VLAN_DEVICES" ]; then
		[ -z "$ALL_DEVICES" ] || ALL_DEVICES="${ALL_DEVICES},"
		ALL_DEVICES="${ALL_DEVICES}${WLAN_VLAN_DEVICES}"
	fi	
	if [ -n "$ETHER_DEVICES" ]; then
		[ -z "$ALL_DEVICES" ] || ALL_DEVICES="${ALL_DEVICES},"
		ALL_DEVICES="${ALL_DEVICES}${ETHER_DEVICES}"
	fi
	if [ -n "$PLC_DEVICE" ]; then
		[ -z "$ALL_DEVICES" ] || ALL_DEVICES="${ALL_DEVICES},"
		ALL_DEVICES="${ALL_DEVICES}${PLC_DEVICE}"
	fi

	eval "$2='${ALL_DEVICES}'"
}


mcs_cfg_add_interface() {
	local all_ifaces
	local switch_lan_vid
	local switch_cpu_root_port

	mcs_cfg_append 'BridgeName=br-'$BR_DEVICE

	# Get a list of all interfaces
	mcs_get_ifaces $BR_DEVICE all_ifaces
	mcs_cfg_append 'ManagedInterfacesList='$all_ifaces

	# Get switch VLAN ID and CPU port
	mcs_get_switch_lan_vid switch_lan_vid
	mcs_get_switch_cpu_port switch_cpu_root_port
	mcs_cfg_append 'SwitchLanVid='"$switch_lan_vid"
	mcs_cfg_append 'SwitchCpuPort='"$switch_cpu_root_port"
}


mcs_create_config() {
	rm -f "$MCSD_CONFIG_FILE"
	mcs_cfg_append ';  Automatically generated mcsd configuration file,do not change it.'
	mcs_cfg_append '[INTERFACE_0]'
	mcs_cfg_add_interface
}

__mcs_get_iptv_ether_ifaces() {
	local config="$1"
	local ifnames network plciface
	local iptv_vlan_id iptv_vlan_backhaul_id

	#config_get ifnames "$config" device
	ifnames=`uci get "network.lan.ifname"`

	config_load iptv_v2
	config_get iptv_vlan_id info iptv_vid "0"
	config_get iptv_vlan_backhaul_id info iptv_backhaul_vid "491"

	local switch_iface
	__mcs_get_switch_iface switch_iface

    local sgmac_support=$(uci -c /etc/profile.d get profile.switch.sgmac)
	local sgmac_if=$(uci -c /etc/profile.d get profile.@DEVINFO[0].eth_root)
	
	if [ "$2" = "$config" ]; then
	   for iface in $ifnames; do
		   [ "$iface" = "$plciface" ] && continue
		if [ "$iface" = "$switch_iface" ]; then
			IPTV_ETHER_DEVICES="${IPTV_ETHER_DEVICES}${IPTV_ETHER_DEVICES:+","}${iface}:ESWITCH"
		else
			IPTV_ETHER_DEVICES="${IPTV_ETHER_DEVICES}${IPTV_ETHER_DEVICES:+","}${iface}:ETHER"
            if [ "${sgmac_support}" != "yes"  ]; then
                if [ -n "$iptv_vlan_id" -a "$iptv_vlan_id" != 0 ]; then
                    IPTV_ETHER_DEVICES="${IPTV_ETHER_DEVICES}${IPTV_ETHER_DEVICES:+","}${iface}${iface:+"."}${iptv_vlan_id}:ETHER"
                fi
                if [ -n "$iptv_vlan_backhaul_id" -a "$iptv_vlan_backhaul_id" != 0 ]; then
                    IPTV_ETHER_DEVICES="${IPTV_ETHER_DEVICES}${IPTV_ETHER_DEVICES:+","}${iface}${iface:+"."}${iptv_vlan_backhaul_id}:ETHER"
                fi
            fi
		fi
	   done
	   
	    if [ -n "$sgmac_support"  ] && [ "${sgmac_support}" = "yes"  ]; then
            if [ -n "$iptv_vlan_id" -a "$iptv_vlan_id" != 0 ]; then
                IPTV_ETHER_DEVICES="${IPTV_ETHER_DEVICES}${IPTV_ETHER_DEVICES:+","}${sgmac_if}${sgmac_if:+"."}${iptv_vlan_id}:ETHER"
            fi
            if [ -n "$iptv_vlan_backhaul_id" -a "$iptv_vlan_backhaul_id" != 0 ]; then
                IPTV_ETHER_DEVICES="${IPTV_ETHER_DEVICES}${IPTV_ETHER_DEVICES:+","}${sgmac_if}${sgmac_if:+"."}${iptv_vlan_backhaul_id}:ETHER"
            fi
        fi
	fi
}


mcs_get_iptv_wlan_vlan_ifaces() {
    local ifnames

    IPTV_WLAN_VLAN_DEVICES=""
    IPTV_WLAN_VLAN_NUM=0

    config_load repacd
    config_get traffic_separation_enabled repacd TrafficSeparationEnabled '0'
    config_get traffic_separation_active repacd TrafficSeparationActive '0'
    config_get backhaul_network repacd NetworkBackhaul 'backhaul'
    if [ "$traffic_separation_enabled" -gt 0 ] && \
        [ "$traffic_separation_active" -gt 0 ]; then
	if [ "$1" == "iptv" ]; then
        	config_load iptv_v2
        	config_get ifnames info vlanifs
	else
        	config_load network
        	config_get ifnames "$1" vlanifs		
	fi
        for iface in $ifnames; do
            if __mcs_is_vlan_iface $iface; then
                if __mcs_is_device_wlan $iface; then
                    IPTV_WLAN_VLAN_DEVICES="${IPTV_WLAN_VLAN_DEVICES}${IPTV_WLAN_VLAN_DEVICES:+","}${iface}:WLAN_VLAN"
                    IPTV_WLAN_VLAN_NUM=$((IPTV_WLAN_VLAN_NUM +1))
                fi
            fi
        done        
    fi

}


mcs_cfg_add_iptv_interface()  {
	IPTV_ETHER_DEVICES=""
	IPTV_WLAN_VLAN_DEVICES=""

	config_load network
	config_foreach __mcs_get_iptv_ether_ifaces interface $br_device
	
	mcs_get_iptv_wlan_vlan_ifaces "$1"

	IPTV_ALL_DEVICES=$IPTV_WLAN_VLAN_DEVICES	
	if [ -n "$IPTV_ETHER_DEVICES" ]; then
		[ -z "$IPTV_ALL_DEVICES" ] || IPTV_ALL_DEVICES="${IPTV_ALL_DEVICES},"
		IPTV_ALL_DEVICES="${IPTV_ALL_DEVICES}${IPTV_ETHER_DEVICES}"
	fi

	mcs_cfg_append 'ManagedInterfacesList='$IPTV_ALL_DEVICES
}


mcs_append_iptv_config() {
	mcs_cfg_append ''
	mcs_cfg_append '[INTERFACE_1]'
	mcs_cfg_append 'BridgeName=br-iptv'
	mcs_cfg_add_iptv_interface "iptv"
}

mcs_append_wan_config() {
	mcs_cfg_append ''
	mcs_cfg_append '[INTERFACE_1]'
	mcs_cfg_append 'BridgeName=br-wan'
	mcs_cfg_add_iptv_interface "wan"
}

mcs_set_wlan_mcastenhance() {
	mcs_get_wlan_vlan_ifaces $BR_DEVICE wlan_ifaces
	[ -z "$wlan_ifaces" ] && return
	#strip device type
	wlan_ifaces=`echo $wlan_ifaces | sed 's/\.[^.]*,/ /g' | sed 's/\.[^.]*/ /g' | tr ' ' '\n' | sort | uniq`

	local igmpSn=1
	if [ "$1" == "1" ]; then
		igmpSn=0
	fi	

	for wlan_iface in ${wlan_ifaces}; do
		iwpriv $wlan_iface set IgmpSnEnable=$igmpSn
	done;
}


start_service() {
	local guest_vlan_id
	config_load wifi
	config_get guest_vlan_id guest vlan_id "0"
	config_clear

	config_load iptv_v2
	config_get iptv_type info iptv_type "normal"
	config_get iptv_vlan_id info iptv_vid "0"
	config_get iptv_vlan_backhaul_id info iptv_backhaul_vid "491"
	config_clear

	config_load 'mcsd'
	config_get_bool enabled config 'Enable' '0'
	
	config_get iptv_ctrl_enabled config 'EnableIptvControl' '1'
	
	[ "$enabled" -gt 0 ] || {
		return 1;
	}

	echo "$guest_vlan_id" >  "$MCSD_VID_FILE"

	# Get bridge name and attach
	mcs_get_bridge_iface br_device

	# Create configuration file and start mcsd
	mcs_create_config


	MANAGED_INF_NUM=$((MANAGED_INF_NUM + WLAN_DEV_READY + WLAN_VLAN_NUM))
	[ "$MANAGED_INF_NUM" -gt 16 ] && {
		echo "Interface number $MANAGED_INF_NUM is more than 16, stop IGMP/MLD snooping" >/dev/console
		mcs_cfg_append "; Managed Interfaces number $MANAGED_INF_NUM is over the limit"
		return
	}

	if [ "$iptv_ctrl_enabled" -gt 0 ]; then
		device_id=$(getfirm DEV_ID)
		role=$(uci get bind_device_list."$device_id".role 2>/dev/null)
		if [ "$role" = "AP" -a "$iptv_type" == "bridge" ]; then
			mcs_append_wan_config
		else
			mcs_append_iptv_config
		fi
	fi

	#Enable wlan WLAN_VLAN multicast enhancement
	mcs_set_wlan_mcastenhance 1

	# By default disable retag of DSCP when multicast enhancement is enabled.
	mcsctl -s br-$br_device retag disable	
	#mcsctl -s br-$br_device state enable

	procd_open_instance
	procd_set_param command ${SERVICE_PATH} -d -C "$MCSD_CONFIG_FILE"
	procd_set_param respawn ${RESPAWN_THRESHOLD} ${RESPAWN_TIMEOUT} ${RESPAWN_RETRIES}
	procd_close_instance	
	
}


stop_service() {

	rm "$MCSD_VID_FILE"
	# Get bridge name and attach
	mcs_get_bridge_iface mcs_bridge
    
	#mcsctl -s br-$mcs_bridge state disable

	# Disable wlan WLAN_VLAN multicast enhancement
	# mcs_set_wlan_mcastenhance 0
}

restart() {
	[ -f "$MCSD_RESTART_PID" ] && {
		local prev_pid=`cat $MCSD_RESTART_PID`
		kill $prev_pid
	}
	echo $$ >  "$MCSD_RESTART_PID"

	stop
	start

	rm "$MCSD_RESTART_PID"
}

service_triggers() {
    procd_add_reload_trigger "wifi"
}

reload_mcsd() {

    if [ -f "$MCSD_VID_FILE" ]; then
        local old_vlan_id=`cat $MCSD_VID_FILE`
        local guest_vlan_id
        config_load wifi
        config_get guest_vlan_id guest vlan_id "0"
        if [ "$old_vlan_id" = "$guest_vlan_id" ]; then
            return 0
        fi
    fi

	restart
} 

reload_service() {
    reload_mcsd &
}

