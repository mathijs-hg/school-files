#!/usr/bin/lua

local AppsError = require "cloud.tp_apps.tp_app_error"
local ifttt = require "cloud.tp_apps.ifttt"
local sys   = require "luci.sys"
local nixio = require "nixio"
local dbg   = require "luci.tools.debug"
local json  = require "luci.json"
local io    = require "io"
local uci_r = uci.cursor()
local getfirm = require "luci.model.getfirm"

local ctl_ifttt = {}
ctl_ifttt.dispatch = ifttt.dispatch
local ctl_tbl = {
    set_trigger = {
        ctl = ctl_ifttt,
        form = "trigger",
        oper = "set"
    },
    
    del_trigger = {
        ctl = ctl_ifttt,
        form = "trigger",
        oper = "del"
    }
}

local TRIGGER_CFG = "ifttt"
local TRIGGER_CFG_NAME = "trigger"
local oldest_propotion = 0.3
local content_type = "Content-type: application/json;charset=utf-8"
local url_postfix = "/cloudDevice"
local CACERT_FILE = "/etc/certificate/2048_newroot.cer"

local retry_count = 0
local token
local origin_url
local fp
local flag = false

local function get_trigger_list()
	local all_list = {}
	local count = 0
    uci_r:foreach(TRIGGER_CFG, TRIGGER_CFG_NAME,
        function(section)
            all_list[#all_list+1] = uci_r:get_all(TRIGGER_CFG, section[".name"])
            count = count + 1
        end
    )
    return all_list, count
end

local function sort_list_by_timestamp(a, b)
	return tonumber(a.time) < tonumber(b.time)
end

local function tableCopy(st)  
    local tab = {}  
    for k, v in pairs(st or {}) do  
        if type(v) ~= "table" then  
            tab[k] = v  
        else  
            tab[k] = tableCopy(v)  
        end  
    end  
    return tab  
end 

while(retry_count <= 2)
do
	retry_count = retry_count + 1
	flag = false

	if not nixio.fs.access("/tmp/cloud/nbu_api_token") then
		sys.call("cloud_getDevToken nbu")
	end

	if nixio.fs.access("/tmp/cloud/nbu_api_token") then
		fp = io.open("/tmp/cloud/nbu_api_token", "r")
		token = fp:read("*line")
		origin_url = fp:read("*line")..url_postfix
		--origin_url = "https://api-ifttt-router.tplinknbu.com" .. url_postfix
		fp:close()
	else
		-- try again when not get the nbu token
		sys.call("cloud_getDevToken nbu")
		if nixio.fs.access("/tmp/cloud/nbu_api_token") then
			fp = io.open("/tmp/cloud/nbu_api_token", "r")
			token = fp:read("*line")
			origin_url = fp:read("*line")..url_postfix
			--origin_url = "https://api-ifttt-router.tplinknbu.com" .. url_postfix
			fp:close()
		else		
			break
		end
	end
		
	local data = {
		["method"] = "syncTriggers",
		["params"] = {
			["deviceToken"] = token,
			["deviceId"] = string.match(getfirm.getfirm_cached("DEV_ID"), "%w+"),
			["triggerIdList"] = {}
		}
	}

	local trigger_list,total = get_trigger_list()
	
	if total < 1 then
		break
	end
	
	table.sort(trigger_list, sort_list_by_timestamp)

	for i=1, total*oldest_propotion, 1 do
		data.params.triggerIdList[#data.params.triggerIdList+1] = tonumber(trigger_list[i].id)
	end
	
	sys.call("echo `date` >/var/log/ifttt_sync.result; echo '%s' >>/var/log/ifttt_sync.result" % {json.encode(data)})
	dbg.print("ifttt request:",json.encode(data))

	local ret
	fp = io.popen("curl -s -S -l -H \"%s\" -X POST -d \'%s\' --cacert %s --connect-timeout 8 %s --retry 3 --retry-delay 1 2>>/var/log/ifttt_sync.result" % {content_type, json.encode(data), CACERT_FILE, origin_url})
	if fp then                                    
		ret = fp:read("*all")                    
		fp:close()                             
	end

	dbg.print("ifttt response:",ret)
	ret = json.decode(ret)

	if ret ~= nil then
		if tonumber(ret.error_code) == AppsError.ERROR_MSG.ERROR_INVAILD_TOKEN[1] then
			--refresh token and upload again
			sys.call("rm /tmp/cloud/nbu_api_token")
			flag = true
		else
			--delete or update the appointed trigger. 
            local delTriggerParams = {}
            local delTriggerList = {}
            for _, triggerId in ipairs(ret.result.deleteTriggerIdList) do
                local del_trigger = {}
                del_trigger.id = triggerId
                delTriggerList[#delTriggerList+1] = del_trigger
			end
            delTriggerParams.trigger_list = delTriggerList
            ifttt.control_dispatch(ctl_tbl.del_trigger, delTriggerParams, ret.result.configVersion)
            
            local upTriggerParams = {}
            local upTriggerList = {}
            for _, v in ipairs(ret.result.remainTriggerIdList) do
                local up_trigger = {}
                up_trigger.id = v.triggerId
                up_trigger.time = v.timestamp
                upTriggerList[#upTriggerList+1] = up_trigger
            end
            upTriggerParams.trigger_list = upTriggerList
            ifttt.control_dispatch(ctl_tbl.set_trigger, upTriggerParams, ret.result.configVersion)
		end
	end

	if flag == false then
		break
	end

end
