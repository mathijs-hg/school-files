#!/bin/sh

## check url and download the firmware.

CLOUD_TMP_DIR="/tmp/cloud/"
#LAST_URL_FILE=${CLOUD_TMP_DIR}"last_download_url"
#CLOUD_DL_PRE_PID=${CLOUD_TMP_DIR}"cloud_dl_pre.pid"
CLOUD_DL_PID=${CLOUD_TMP_DIR}"cloud_dl.pid"
CLOUD_DL_HEAD=${CLOUD_TMP_DIR}"cloud_dl.head"
CLOUD_FW_LENGTH=${CLOUD_TMP_DIR}"cloud_fw.length"
TIMEOUT=10

[ $# -lt 2 ] && echo Please input: url file && exit 0

## for download status check, wl, 2016.12.22
echo $$ >> ${CLOUD_DL_PID}

### check the internet, or check whether the remote file is exist or not. 
[ ! -d ${CLOUD_TMP_DIR} ] && mkdir ${CLOUD_TMP_DIR}
curl -s --head --connect-timeout 10 -g -m 10 "$1" > ${CLOUD_DL_HEAD}
re=$(cat ${CLOUD_DL_HEAD}|grep -w HTTP|awk '{print $2}')
[ "$re" != "200" ] && {
	### don't need to remove up.bin when get remote file failed, fail may cause by poor connection.
    #rm -rf $2
	echo "poor network.." >/dev/console 2>&1
	rm ${CLOUD_DL_PID}
    exit
}

dl_protect=$(uci -c /etc/profile.d get profile.mem_protect.dl_support)
if [ -n "$dl_protect" ] && [ "yes" == "$dl_protect" ]; then
    fw_len=$(cat ${CLOUD_DL_HEAD} | grep -w Length | awk '{print $2}')
    mem_free=$(cat /proc/meminfo | grep MemFree | awk '{print $2}')
    fw_name=$(echo "$2" | cut -d '/' -f 3)
    downloaded_len=$(ls -l /tmp/ | grep "$fw_name" | awk '{print $5}')
    safe_mem=10240

    if [ -n "$fw_len" ] && [ -n "$mem_free" ]; then

        echo "fw_len:$fw_len and mem:$mem_free" > /dev/console 2>&1
        fw_len=$((fw_len/1024))
        total_need=$((fw_len+safe_mem))

        if [ -n "$downloaded_len" ]; then
            echo "continue to dowmload, has downloaded $downloaded_len of $2" > /dev/console 2>&1
            downloaded_len=$((downloaded_len/1024))
            total_need=$((total_need-downloaded_len))
        fi

        echo "total is $total_need" > /dev/console 2>&1

        if [ $mem_free -gt $total_need ]; then
            echo "we can dl now" > /dev/console 2>&1
        else
            echo "free mem is not enough!!!!" > /dev/console 2>&1
            rm ${CLOUD_DL_PID}
            exit
        fi

    fi
fi

#[ ! -f ${LAST_URL_FILE} ] && touch ${LAST_URL_FILE}
#[ ! -f ${CLOUD_DL_PID} ] && touch ${CLOUD_DL_PID}
#last_url=`cat ${LAST_URL_FILE}`
#pid=`cat ${CLOUD_DL_PID}`
#if [ "${last_url}" != "$1" ]; then
#	rm -rf $2
#	[ ! -z ${pid} ] && kill -9 ${pid}
#	cat ${CLOUD_DL_HEAD}|grep -w Length|awk '{print $2}' > ${CLOUD_FW_LENGTH}
#else
#	if [ -f "/proc/${pid}/status" ]; then
#		echo "prpocess still exist." >/dev/console 2>&1 
#		rm ${CLOUD_DL_PRE_PID}
#		return 0
#	fi
#fi

######################################################################################
###	-C, --continue-at OFFSET  	Resumed transfer offset								
### -#, --progress-bar  		Display transfer progress as a progress bar
### -L, --location      		Follow 	redirects
### -e, --referer       		Referer URL
### -o, --output FILE   		Write output to <file> instead of stdout
### -g, --globoff       		Disable URL sequences and ranges using {} and []
### -Y, --speed-limit RATE  	Stop transfers below speed-limit for 'speed-time' secs
### -y, --speed-time SECONDS  	Time for trig speed-limit abort. Defaults to 30
#######################################################################################
echo "Begin to download firmware" >/dev/console 2>&1
curl -C - -# -L -4 -e ';auto' -o "$2" -g "$1" --connect-timeout 10 -m 600 -Y 1 -y ${TIMEOUT} > /dev/null 2>&1 &
echo $! >> ${CLOUD_DL_PID}
#echo $1 > ${LAST_URL_FILE}

## for download status check, wl, 2016.12.22
#rm ${CLOUD_DL_PRE_PID}
