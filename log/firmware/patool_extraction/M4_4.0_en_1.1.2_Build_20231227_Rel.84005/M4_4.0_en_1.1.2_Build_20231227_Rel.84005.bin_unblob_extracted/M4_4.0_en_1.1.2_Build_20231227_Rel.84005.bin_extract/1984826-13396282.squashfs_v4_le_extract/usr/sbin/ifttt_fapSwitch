#!/usr/bin/lua

local AppsError = require "cloud.tp_apps.tp_app_error"
local ifttt = require "cloud.tp_apps.ifttt"
local sys   = require "luci.sys"
local nixio = require "nixio"
local dbg   = require "luci.tools.debug"
local json = require "luci.json"
local io    = require "io"
local clientmgmt = require "luci.model.app_clientmgmt"
local uci_r = uci.cursor()

local ctl_ifttt = {}
ctl_ifttt.dispatch = ifttt.dispatch
local ctl_tbl = {
    del_trigger = {
        ctl = ctl_ifttt,
        form = "trigger",
        oper = "del"
    }
}

local TRIGGER_CFG = "ifttt"
local TRIGGER_CFG_NAME = "trigger"

local content_type = "Content-type: application/json;charset=utf-8"
local url_postfix = "/cloudDevice"
local CACERT_FILE = "/etc/certificate/2048_newroot.cer"

local retry_count = 0
local token
local origin_url
local fp
local flag = false

local old_devid = arg[1]
local new_devid = arg[2]

local get_nbu_count = 0

while(retry_count <= 2)
do
	retry_count = retry_count + 1
	flag = false

	-- ensure /tmp/cloud/nbu_api_token exists , otherwise this event can not be upload to cloud.
	while(get_nbu_count < 10)
	do
		if not nixio.fs.access("/tmp/cloud/nbu_api_token") then
			get_nbu_count = get_nbu_count + 1
			sys.call("cloud_getDevToken nbu")
			os.execute("sleep " .. 10)
		else
			break
		end
	end
	dbg.print( "cloud_getDevToken_nbu tried " ..  get_nbu_count .. " times for ifttt")

	if nixio.fs.access("/tmp/cloud/nbu_api_token") then
		fp = io.open("/tmp/cloud/nbu_api_token", "r")
		token = fp:read("*line")
		origin_url = fp:read("*line")..url_postfix
		--origin_url = "https://api-ifttt-router.tplinknbu.com" .. url_postfix
		fp:close()
	else
		-- try again when not get the nbu token
		sys.call("cloud_getDevToken nbu")
		if nixio.fs.access("/tmp/cloud/nbu_api_token") then
			fp = io.open("/tmp/cloud/nbu_api_token", "r")
			token = fp:read("*line")
			origin_url = fp:read("*line")..url_postfix
			--origin_url = "https://api-ifttt-router.tplinknbu.com" .. url_postfix
			fp:close()
		else		
			break
		end
	end
		
	local data = {
		["method"] = "fapSwitchEvents",
		["params"] = {
			["version"] = 1,
			["deviceToken"] = token,
			["deviceId"] = new_devid,
			["oldDeviceId"] = old_devid
		}
	}
	dbg.print(json.encode(data))
	
	sys.call("echo `date` >/var/log/ifttt_fap_switch.result; echo '%s' >>/var/log/ifttt_fap_switch.result" % {json.encode(data)})
	dbg.print("ifttt request:",json.encode(data))

	local ret
	fp = io.popen("curl -s -S -l -H \"%s\" -X POST -d \'%s\' --cacert %s --connect-timeout 5 %s --retry 3 --retry-delay 1 2>>/var/log/ifttt_fap_switch.result" % {content_type, json.encode(data), CACERT_FILE, origin_url})
	if fp then                                    
		ret = fp:read("*all")                    
		fp:close()                             
	end

	dbg.print("ifttt response:" .. ret)
	ret = json.decode(ret)

	if ret ~= nil then
		if tonumber(ret.error_code) == AppsError.ERROR_MSG.ERROR_INVAILD_TOKEN[1] then
			--refresh token and upload again
			sys.call("rm /tmp/cloud/nbu_api_token")
			flag = true
		elseif tonumber(ret.error_code) == AppsError.ERROR_MSG.ERROR_UNMATCHED_TRIGGER_ITEM[1] then
			--delete the appointed trigger. 
            --[[
			for _, list in ipairs(ret.triggerIdList) do
				uci_r:delete_all(TRIGGER_CFG, TRIGGER_CFG_NAME,
					function(section)
						old_trigger = uci_r:get_all(TRIGGER_CFG, section[".name"])
						return tonumber(old_trigger.id) == tonumber(list)
					end
				)		
			end
			uci_r:commit(TRIGGER_CFG)
            --]]
            local delTriggerParams = {}
            local delTriggerList = {}
            for _, triggerId in ipairs(ret.triggerIdList) do
                local del_trigger = {}
                del_trigger.id = triggerId
                delTriggerList[#delTriggerList+1] = del_trigger		
			end
            delTriggerParams.trigger_list = delTriggerList
            ifttt.control_dispatch(ctl_tbl.del_trigger, delTriggerParams, ret.configVersion)
		end
	end
	
	if flag == false then
		break
	end
	
end

-- os.execute("rm -f %s" % {file_path})
