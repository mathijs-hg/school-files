#!/usr/bin/lua

local tmpv2 = require "tmpv2"
local json = require "luci.json"
local sync = require "luci.model.sync"
local subprocess = require "luci.model.subprocess"
local dbg = require "luci.tools.debug"
local util = require "luci.util"
local nixio = require "nixio"
local fs = require "nixio.fs"
local Locker = require("luci.model.locker").Locker
local script = require "sync-script"

local CONFIG_LOCK = "/var/run/config.lock"

local group = sync.read_group_info()
local version = sync.get_config_version()
local sync_ver = sync.get_sync_version()
local config_file = nil

local RECORD_DEVID = "/var/run/record_devid"
local MESH_DEV_LIST = "/tmp/sync-server/mesh_dev_list"
local update = require "update-info"
local my_devid = sync.get_device_id()

local function get_data(path)
    local fp = io.open(path, "r")
    local data = {}
    if fp == nil then
        dbg("error open file failed:" .. path)
        return data
    end
    local lines = fp:read("*all")
    fp:close()
    data = json.decode(lines)
    return data
end

local function get_re_args()
    local uci = require "luci.model.uci"
    local uci_s = uci.cursor_state()
    local my_mode = uci_s:get("repacd", "repacd", "DeviceType")

    if my_mode ~= "AP" then
        return nil
    end

    local record_devid = get_data(RECORD_DEVID)
    local mesh_dev_list = get_data(MESH_DEV_LIST)

    if update.is_nil_table(record_devid) or update.is_nil_table(mesh_dev_list) then
        dbg("error: record_devid or mesh_dev_list is nil, do nothing")
        return nil
    end

	local arg = {}
    for index=1, #record_devid do
        local recode_id = record_devid[index]
        local dev_info = mesh_dev_list[recode_id]
        if recode_id ~= my_devid then
            if dev_info == nil then
                dbg("in record_devid but not in mesh_dev_list, don't sync config " .. json.encode(recode_id))
            else
                local ip = dev_info["ip"]
				table.insert(arg, ip)
				table.insert(arg, "1")
            end
		end
    end
	return arg
end

local function sync_proc(tmpcli)
	local TRY_TIME = 20
	local cnt = 0
	data = nil
	while cnt < TRY_TIME do
		data, msg = tmpcli:request("SYNC_CHECK", json.encode{
									   params = {
										   group_id = group.gid,
										   config_version = version,
										   sync_version = sync_ver
									   }
		})
		data, msg = script.check_tmp_data(data, msg)
		if data then
			break
		end
		dbg("SYNC_CHECK sleep, msg:" .. json.encode(msg) .. " cnt " .. cnt)
		nixio.nanosleep(2, 0)
		cnt = cnt+1
	end
    if not data then
        return nil, msg
    end

	cnt = 0
	data = nil
	while cnt < TRY_TIME do
		data, msg = tmpcli:request("SYNC_CONFIG", {infile = config_file})
		data, msg = script.check_tmp_data(data, msg)
		if data then
			break
		end
		dbg("SYNC_CONFIG sleep, msg:" .. json.encode(msg) .. " cnt " .. cnt)
		nixio.nanosleep(2, 0)
		cnt = cnt+1
	end
    if not data then
        return nil, msg
    end

    return true
end

local function main()
	local arg = get_re_args()
	if update.is_nil_table(arg) then
		return
	end
	dbg("arg:" .. json.encode(arg))
	local num = tonumber(#arg/2)
	dbg("Total %d devices need to be updated" % num)

	local rc = subprocess.call({"fullband-switch"})   

	config_file = "/tmp/config-sync-%d-%d.bin" % {os.time(), nixio.getpid()}

	local locker = Locker(CONFIG_LOCK)
	locker:lock()
	rc = subprocess.call({"nvrammanager", "-p", "user-config", "-r", config_file})
	locker:close()

	if rc ~= 0 then
		dbg("Failed to read config partition")
		return 1
	end

	local data = script.reduce_concurrent(sync_proc, nil, nil, arg, 1, #arg)
	if data.errmsg then
		dbg("Warning: collected errors:", data.errmsg)
	end
	dbg("Total %d devices were updated successfully" % data.success)

	fs.unlink(config_file)
end

script.run(main)
