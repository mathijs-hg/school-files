#!/bin/sh /etc/rc.common
# Copyright (c) 2015 Qualcomm Atheros, Inc.
#
# All Rights Reserved.
# Qualcomm Atheros Confidential and Proprietary.

START=44  # needs to be after LED init

SERVICE_WRITE_PID=1
SERVICE_DAEMONIZE=1
#SERVICE_DEBUG=1
NETWORK_RESTART=0
SERVICE_DEBUG_OUTPUT=0
REPACD_DEBUG_OUTOUT=1
LEVEL=6
# These restart_in_*_mode commands are only intended to be used by
# repacd-run.sh.
#
# - restart_in_cap_mode is used when the device has a direct connection to the
#   the gateway via ethernet. This will result in only the AP interfaces being
#   enabled.
# - restart_in_noncap_mode is used when the device no longer has a direction
#   connection to the gateway via ethernet. When this is done, the device will
#   either have both its AP and STA interfaces enabled (if its primary purpose
#   is as a standalone RE) or just its STA interface enabled (if its primary
#   purpose is as a client device).
# - restart_in_re_mode is used when a device that is intended to primarily
#   act as a client actually has sufficient link quality to act as a range
#   extender. It will enable both the STA and AP interfaces.
EXTRA_COMMANDS="restart_in_cap_mode restart_in_noncap_mode restart_in_re_mode"
EXTRA_HELP=<<EOF
        restart_in_cap_mode Reconfigure the system into Central AP mode
        restart_in_noncap_mode Reconfigure the system into Non Central AP mode
        restart_in_re_mode Reconfigure the system into Range Extender mode
EOF

local WSPLCD_INIT='/etc/init.d/wsplcd'
local HYFI_BRIDGING_INIT='/etc/init.d/hyfi-bridging'
local HYFI_FILTER='hyfi_filter'
local HYD_INIT='/etc/init.d/hyd'
local LBD_INIT='/etc/init.d/lbd'
local WIFI_TYPE_BCM='/tmp/g_wifi_type_bcm'

. /lib/functions/whc-debug.sh
. /lib/functions/whc-iface.sh
. /lib/functions/whc-network.sh
. /lib/wifi/wificommon.sh
. /usr/lib/eth-encap/eth_encap.sh

RE_DEFAULT_RATE_ESTIMATE_SCALING_FACTOR='70'
IPTV_BACKHAUL_FILE="/tmp/iptv_backhaul_file"

local wifi_cmd
local managed_network config_changed=0 son_changed=0
local vap_defconf=1
local config_re_mode resolved_re_mode resolved_re_submode
local hyd_start=0 hyd_stop=0
local firewall_restart=0

local network_guest
local guest_backhaul_iface
local network_spcl="backhaul"
local guest_ssid_suffix="guest" spcl_ssid_suffix="backhaul"
local traffic_separation_enabled traffic_separation_active create_sta=0
local traffic_plc_is_root traffic_plc_as_eth 
local ssid_copy enc_copy key_copy
local vlan1_ports= vlan2_ports= vlan1_remaining_ports= vlan1_port_count=0
local inc=1
local daisy_chain=0 bssid_updated=0
local sta_24g sta_5g
local wlan_backhaul_devices_2G wlan_backhaul_devices_5G
local ap_5g1 ap_5g2
local eth_vid
local guest_vlan_enable
local guest_mix
local guest_isolate

local iptv_network="iptv"
local wan_network="wan"
local iptv_backhaul_id=3
local is_iptv_ap_only="1"
local isDcmp='isDcmp 2>/dev/null'
local switch_chip=$(uci -c /etc/profile.d get profile.switch.switch_chip)
local plc_backhaul_vid="1"
local plc_guest_vid="2"
local plc_iptv_vid="$iptv_backhaul_id"
config_load plc_sync
config_get plc_bkhl_vlan vlan backhaul_vlan_id '191'
config_get plc_gst_vlan vlan guest_vlan_id '291'
config_get plc_iptv_vlan vlan iptv_vlan_id '391'
config_clear
if [ "$switch_chip" = "rtk_gsw" ]; then
    plc_backhaul_vid="$plc_bkhl_vlan"
    plc_guest_vid="$plc_gst_vlan"
    plc_iptv_vid="$plc_iptv_vlan"
fi

# Write the provided log message to the correct output stream.
# If REPACD_DEBUG_OUTOUT is non-zero, it will be written to the console.
# Otherwise, it will be written to stdout.
__repacd_echo() {
    if [ "$REPACD_DEBUG_OUTOUT" -gt 0 ]; then
        echo "whc (repacd): $1" > /dev/console
        logger -p $LEVEL "whc (repacd): $1"
    else
       #echo "whc (repacd): $1"
        logger -p $LEVEL "whc (repacd): $1"
    fi
}

# Determine if the network is configured or not.
#
# input: $1 network name
# return: 0 if network exist; otherwise non-zero
__repacd_network_exist() {
    local lan_name=$1
    local no_network

    no_network=`uci show network.$lan_name 2>&1 | grep 'Entry not found'`
    [ -n "$no_network" ] && return 1

    return 0
}

# Determine if additional network exist.
# Currently looking out for only guest network.
#
# input: $1 network name
# return: 0 if exist; otherwise non-zero
__repacd_check_additional_network_exist() {

    return 0
}

# Add the given interface to the given network.
# input: $1 network name
# input: $2 interface name
__repacd_add_interface() {
    local name=$1 new_if="$2"
    local if_name

    config_load network
    if __repacd_network_exist $name; then
        if [ -n "$new_if" ]; then
            if_name=`uci get network.$name.ifname`
            if [ -n "$if_name" ]; then
                if_name="$if_name $new_if"
            else
                if_name="$new_if"
            fi
            uci set network.$name.ifname="$if_name"
        fi
        uci_commit network
    fi
}

__repacd_add_vlan_interface() {
    local name=$1 new_if="$2"
    local if_name

    if [ "$name" = "iptv" ]; then
        config_load iptv_v2
        if [ -n "$new_if" ]; then
            config_get if_name info vlanifs
            if [ -n "$if_name" ]; then
                [ "$if_name" = "${if_name/$new_if}" ] && if_name="$if_name $new_if"
            else
                if_name="$new_if"
            fi
            uci_toggle_state iptv_v2 info vlanifs "$if_name"
        fi
        uci_commit iptv_v2

    elif __repacd_network_exist $name; then
        config_load network
        if [ -n "$new_if" ]; then
            config_get if_name "$1" vlanifs
            if [ -n "$if_name" ]; then
                [ "$if_name" = "${if_name/$new_if}" ] && if_name="$if_name $new_if"
            else
                if_name="$new_if"
            fi
            uci_toggle_state network "$name" vlanifs "$if_name"
        fi
        uci_commit network
    fi
}

__repacd_add_plc_interface() {
    local name=$1 new_if="$2"
    local if_name

    config_load network
    if __repacd_network_exist $name; then
        if [ -n "$new_if" ]; then
            config_get if_name "$1" plcIfs
            if [ -n "$if_name" ]; then
                [ "$if_name" = "${if_name/$new_if}" ] && if_name="$if_name $new_if"
            else
                if_name="$new_if"
            fi
            uci_toggle_state network "$name" plcIfs "$if_name"
        fi
        uci_commit network
    fi
}

__repacd_del_vlan_interface() {
    local name=$1 del_if="$2"
    local if_name

    if [ "$name" = "iptv" ]; then
        config_load iptv_v2
        if [ -n "$del_if" ]; then
            config_get if_name info vlanifs
            if [ -n "$if_name" ]; then
                if_name="${if_name/$del_if}"
                uci_toggle_state iptv_v2 info vlanifs "$if_name"
            fi
        fi
        uci_commit iptv_v2
    elif __repacd_network_exist $name; then
        config_load network
        if [ -n "$del_if" ]; then
            config_get if_name "$1" vlanifs
            if [ -n "$if_name" ]; then
                if_name="${if_name/$del_if}"
                uci_toggle_state network "$name" vlanifs "$if_name"
            fi
        fi
        uci_commit network
    fi
}

__repacd_del_plc_interface() {
    local name=$1 del_if="$2"
    local if_name

    config_load network
    if __repacd_network_exist $name; then
        if [ -n "$del_if" ]; then
            config_get if_name "$1" plcIfs
            if [ -n "$if_name" ]; then
                if_name="${if_name/$del_if}"
                uci_toggle_state network "$name" plcIfs "$if_name"
            fi
        fi
        uci_commit network
    fi
}


_get_wlan_ifaces() {
    local config="$1"
    local iface network ssid disabled mode is5g

    if [ -f $WIFI_TYPE_BCM ]; then
        config_get iface "$config" vapname
    else
        config_get iface "$config" ifname
    fi
    config_get ssid "$config" ssid
    config_get disabled "$config" disabled '0'
    config_get mode "$config" mode 'ap'

    if [ -n "$iface" -a "$2" = "$ssid" -a "$disabled" -eq 1 ] && [ "$mode" = "sta" ]; then
        if [ -L /sys/devices/virtual/net/br-lan/brif/$iface ]; then
            __repacd_echo "sta ifcace $iface, disabled:$disabled, delete it form br-lan"
            brctl delif br-lan "$iface"
        fi
    fi

    if [ -n "$iface" -a "$2" = "$ssid" -a "$disabled" -eq 0 ]; then
        whc_is_5g_vap $config
        is5g="$?"
        if [ "$is5g" = "0" ]; then
            wlan_backhaul_devices_5G="${wlan_backhaul_devices_5G}${wlan_backhaul_devices_5G:+" "}${iface}"
        elif [ "$is5g" = "1" ]; then
            wlan_backhaul_devices_2G="${wlan_backhaul_devices_2G}${wlan_backhaul_devices_2G:+" "}${iface}"          
        fi
    fi
}
    

__repacd_get_spcl_interfaces_from_config() {
    local ssid ssidcfg ssidpre
    local ssidpreconfig
    local ssid ssidcfg ssidpre ssidsta
    wlan_backhaul_devices_2G=
    wlan_backhaul_devices_5G=

    config_load 'wifi'
    config_get ssid backhaul 'ssid' 'backhaul'
    config_get ssidcfg config 'ssid' 'config'
    config_get ssidpre config 'pre_ssid' 'preconfig'
    if [ "$isDcmp" = "yes" ]; then
        config_get ssidpreconfig preconfig 'ssid' 'preconfig'
    fi
    config_get ssidsta sta 'ssid' 'backhaul'
    
    config_load wireless
    config_foreach _get_wlan_ifaces wifi-iface $ssid
    config_foreach _get_wlan_ifaces wifi-iface $ssidcfg
    config_foreach _get_wlan_ifaces wifi-iface $ssidpre
    if [ "$isDcmp" = "yes" ]; then
        config_foreach _get_wlan_ifaces wifi-iface $ssidpreconfig
    fi
    
    [ "$ssidsta" != "$ssid" -a "$ssidsta" != "$ssidcfg" -a "$ssidsta" != "$ssidpre" ] && {
        config_foreach _get_wlan_ifaces wifi-iface $ssidsta
    }

[32m    eval "$1='$wlan_backhaul_devices_2G'"[0m
[32m    eval "$2='$wlan_backhaul_devices_5G'"        [0m
}


# Get spcl interfaces.Interfaces with suffix spcl in their SSID.
# input: $1 band either 2.4G or 5G
# output: $2 - variable into which we populate interface list.
__repacd_get_spcl_interfaces() {
    if [ -f $WIFI_TYPE_BCM ]; then
        local wlan_backhaul_devices_2G
        local wlan_backhaul_devices_5G
        local ifaces_plc=

        if [ "$1" = '2.4G' -o "$1" = '5G' ]; then
            __repacd_get_spcl_interfaces_from_config wlan_backhaul_devices_2G wlan_backhaul_devices_5G
            if [ "$1" = '2.4G' ]; then
[32m                eval "$2='$wlan_backhaul_devices_2G'"[0m
            elif [ "$1" = '5G' ]; then
[32m                eval "$2='$wlan_backhaul_devices_5G'"[0m
            fi

        elif [ "$1" = 'plc' ]; then
            local plciface
            config_load plc
            config_get plciface config PlcIfname
            [ -d /sys/class/net/$plciface ] && ifaces_plc=`echo $plciface`
[32m            eval "$2='$ifaces_plc'"[0m
        fi
    else
        local ifaces
        local ifaces_24g
        local ifaces_5g
        local ifaces_plc=
        local ssid ssidcfg

        config_load 'wifi'
        config_get ssid backhaul 'ssid' 'backhaul'
        config_get ssidcfg config 'ssid' 'config'

        ifaces=`iwconfig 2>&1 | grep "\($ssid\)\|\($ssidcfg\)"`
        if [ "$1" = '2.4G' ]; then
            ifaces_24g=`echo "$ifaces" | grep -E '11b|11g|11ng' | cut -d ' ' -f1`
[32m            eval "$2='$ifaces_24g'"[0m
        elif [ "$1" = '5G' ]; then
            ifaces_5g=`echo "$ifaces" | grep -E '11a|11na|11ac' | cut -d ' ' -f1`
[32m            eval "$2='$ifaces_5g'"[0m
        elif [ "$1" = 'plc' ]; then
            local plciface
            if [ "$switch_chip" = "rtk_gsw" ]; then
                # should set to switch CPU port name
                plciface=$(uci -c /etc/profile.d get interfaces.plc.name)
            else
                config_load plc
                config_get plciface config PlcIfname
            fi
            [ -d /sys/class/net/$plciface ] && ifaces_plc=`echo $plciface`
[32m            eval "$2='$ifaces_plc'"[0m
        fi
    fi
}

__repacd_fix_bridge_addr() {
    local network=$1
    local interface=$2
    
    config_load network
    config_get hwaddr $network macaddr
    
    [ "$managed_network" = "$network" ] && return
    
    
    [ -z "$hwaddr" ] && {
        #
        # For mtk wireless driver, if br-iptv's mac is same as apcli0's mac, FAP wireless driver will receive a four address packet
        # which's source mac is br-iptv's mac. Then it will think the RE has roamed, and delete this RE from it's mactable.
        #
        if [ "$network" = "iptv" ]; then
            local mac=$(getfirm MAC)
            mac=${mac//-/:}
            local local_mac=$((0x${mac:0:2}|2))
            local_mac=$(printf %02X $local_mac)
            mac=${mac/${mac:0:2}/$local_mac}
        else
            local mac=$(cat /sys/class/net/$interface/address)
        fi
        ifconfig br-$network hw ether $mac
        uci_toggle_state network $network macaddr $mac  
    }
}

__repacd_mv_vlan_interfaces() {
    local iface=$1
    local vid=$2
    local old_network=$3
    local new_network=$4

    __repacd_del_vlan_interface $old_network "$iface.$vid"
    ifconfig $iface.$vid down
    [ $vid = 2 ] && {
    	ubus call network.interface."$old_network" remove_device "{ \"name\": \"$iface.$vid\" }"
    }
    brctl delif "br-$old_network" "$iface.$vid"
    
    brctl addif "br-$new_network" "$iface.$vid"
    ifconfig $iface.$vid up
    [ $id = 2 ] && {
    	ubus call network.interface."$new_network" add_device "{ \"name\": \"$iface.$vid\" }"
    }
    __repacd_add_vlan_interface $new_network "$iface.$vid"

}

# Create VLAN interfaces for all the special vaps that we create and add the
# created interfaces to the given network.
# VLAN interfaces are created by concatenating interface name and vlan id.
# input: $1 network name
# input: $2 VLAN id
__repacd_add_vlan_interfaces() {
    local spcl_interfaces_5g
    local spcl_interfaces_24g
    local spcl_interfaces_plc
    local id=$2
    local network=$1
    local backhaul_iface=$3
    local interface
    local ifname master 
    local master_link master_dev master_network
    local iface_type iface_mode

    __repacd_echo "do __repacd_add_vlan_interfaces network:$network vlan id:$id backhual_iface:$backhaul_iface"
    if [ "$backhaul_iface" = 'both' ]; then
        __repacd_get_spcl_interfaces_from_config spcl_interfaces_24g spcl_interfaces_5g
        __repacd_get_spcl_interfaces 'plc' spcl_interfaces_plc
    elif [ "$backhaul_iface" = 'wifi' ]; then
        __repacd_get_spcl_interfaces_from_config spcl_interfaces_24g spcl_interfaces_5g
    elif [ "$backhaul_iface" = 'plc' ]; then
         __repacd_get_spcl_interfaces 'plc' spcl_interfaces_plc                       
    elif [ "$backhaul_iface" = '5G' ]; then
        __repacd_get_spcl_interfaces '5G' spcl_interfaces_5g
    else
        __repacd_get_spcl_interfaces '2.4G' spcl_interfaces_24g
    fi
    
    __repacd_echo "2g interfaces:$spcl_interfaces_24g, 5g interfaces:$spcl_interfaces_5g" 
    __repacd_echo "plc interfaces:$spcl_interfaces_plc" 

    if [ -n "$spcl_interfaces_5g" ]; then
        for interface in $spcl_interfaces_5g; do
            echo "interface5g:$interface" >/dev/console
            if [ -f $WIFI_TYPE_BCM ]; then
                iface_type=$(uci get wireless.$interface.type)
                iface_mode=$(uci get wireless.$interface.mode)
                if [ $iface_type = "config" ] || [ $iface_type = "backhaul" -a $iface_mode = "ap" ]; then
                    continue
                fi
                ifname=$(brctl show br-$network | grep "$interface.$id")
            else
                master=`iwconfig $interface | grep "Master"`
                ifname=`iwconfig 2>&1 | grep "$interface.$id" | cut -d ' ' -f1`
            fi
            if [ -z "$ifname" ]; then
                __repacd_echo "$interface.$id does not exist, add it."
                if [ -f $WIFI_TYPE_BCM ] && [ -L /sys/devices/virtual/net/br-$network/brif/$interface ]; then
                    echo "$interface exist, delete it" >/dev/console
                    brctl delif "br-$network" "$interface"
                fi
                vlan_add $interface $id
                __repacd_fix_bridge_addr $network $interface
                brctl addif "br-$network" "$interface.$id"
                ifconfig $interface.$id up

                # set dwds group for BCM DWDS interface
                if [ -f /usr/bin/dwds_ctl ]; then
                    dwds_ctl set_group "$interface.$id" 30
                fi

                [ $id = 2 ] && {
                    #guest network
                    #echo "repacd_$interface.$id-$network" > /dev/console
                    ubus call network.interface."$network" add_device "{ \"name\": \"$interface.$id\" }"
                }

                __repacd_add_vlan_interface $network "$interface.$id"
                config_changed=1
            else 
                master_dev=
                if [ -d /sys/class/net/$interface.$id/master ]; then
                    master_link=$(readlink /sys/class/net/$interface.$id/master)
                    master_dev=${master_link##*/}
                fi
                if [ -n "$master_dev" ] && [ "$master_dev" != "br-$network" ]; then
                    master_network=${master_dev/br-/}
                    __repacd_mv_vlan_interfaces $interface $id $master_network $network
                    config_changed=1
                else
                    __repacd_echo "$ifname already existed, do nothing."
                fi
            fi
        done
    fi

    if [ -n "$spcl_interfaces_24g" ]; then
        for interface in $spcl_interfaces_24g; do
            echo "interface2g:$interface" >/dev/console        
            if [ -f $WIFI_TYPE_BCM ]; then
                iface_type=$(uci get wireless.$interface.type)
                iface_mode=$(uci get wireless.$interface.mode)
                if [ $iface_type = "config" ] || [ $iface_type = "backhaul" -a $iface_mode = "ap" ]; then
                    continue
                fi
                ifname=$(brctl show br-$network | grep "$interface.$id")
            else
                master=`iwconfig $interface | grep "Master"`
                ifname=`iwconfig 2>&1 | grep "$interface.$id" | cut -d ' ' -f1`
            fi
            if [ -z "$ifname" ]; then
                __repacd_echo "$interface.$id does not exist, add it."
                if [ -f $WIFI_TYPE_BCM ] && [ -L /sys/devices/virtual/net/br-$network/brif/$interface ]; then
                    echo "$interface exist, delete it" >/dev/console
                    brctl delif "br-$network" "$interface"
                fi
                vlan_add $interface $id
                __repacd_fix_bridge_addr $network $interface                
                brctl addif "br-$network" "$interface.$id"
                ifconfig $interface.$id up

                # set dwds group for BCM DWDS interface
                if [ -f /usr/bin/dwds_ctl ]; then
                    dwds_ctl set_group "$interface.$id" 30
                fi

                [ $id = 2 ] && {
                    #guest network
                    #echo "repacd_$interface.$id-$network" > /dev/console
                    ubus call network.interface."$network" add_device "{ \"name\": \"$interface.$id\" }"
                }

                __repacd_add_vlan_interface $network "$interface.$id"               
                config_changed=1
            else 
                master_dev=
                if [ -d /sys/class/net/$interface.$id/master ]; then
                    master_link=$(readlink /sys/class/net/$interface.$id/master)
                    master_dev=${master_link##*/}
                fi
                if [ -n "$master_dev" ] && [ "$master_dev" != "br-$network" ]; then
                    master_network=${master_dev/br-/}
                    __repacd_mv_vlan_interfaces $interface $id $master_network $network
                    config_changed=1
                else
                    __repacd_echo "$ifname already existed, do nothing."
                fi
            fi
        done
    fi
    
    if [ -n "$spcl_interfaces_plc" ]; then
        for interface in $spcl_interfaces_plc; do
            ifname=`ifconfig 2>&1 | grep "$interface.$id" | cut -d ' ' -f1`
            if [ -z "$ifname" ]; then
                __repacd_echo "$interface.$id does not exist, add it."
                vlan_add $interface $id
                brctl addif "br-$network" "$interface.$id"
                ifconfig $interface.$id mtu 1500
                ifconfig $interface.$id up
                __repacd_add_plc_interface $network "$interface.$id"               
                config_changed=1
            else 
                master_dev=
                if [ -d /sys/class/net/$interface.$id/master ]; then
                    master_link=$(readlink /sys/class/net/$interface.$id/master)
                    master_dev=${master_link##*/}
                fi
                if [ -n "$master_dev" ] && [  "$master_dev" != "br-$network" ]; then
                    master_network=${master_dev/br-/}
                    __repacd_mv_vlan_interfaces $interface $id $master_network $network
                    config_changed=1
                else
                    __repacd_echo "$ifname already existed, do nothing."
                fi
            fi
        done
    fi    

}


# Create VLAN interfaces for all the special vaps that we create and add the
# created interfaces to the given network.
# VLAN interfaces are created by concatenating interface name and vlan id.
# input: $1 network name
# input: $2 VLAN id
__repacd_del_vlan_interfaces() {
    local spcl_interfaces_5g
    local spcl_interfaces_24g
    local spcl_interfaces_plc    
    local id=$2
    local network=$1
    local backhaul_iface=$3
    local interface_type=$4
    local interface
    local ifname
    local mode
    local iface_type iface_mode

    __repacd_echo "do __repacd_del_vlan_interfaces network:$network vlan id:$id backhual_iface:$backhaul_iface"

    if [ "$backhaul_iface" = 'both' ]; then
        __repacd_get_spcl_interfaces_from_config spcl_interfaces_24g spcl_interfaces_5g
        __repacd_get_spcl_interfaces 'plc' spcl_interfaces_plc
    elif [ "$backhaul_iface" = 'wifi' ]; then
        __repacd_get_spcl_interfaces_from_config spcl_interfaces_24g spcl_interfaces_5g
    elif [ "$backhaul_iface" = 'plc' ]; then
         __repacd_get_spcl_interfaces 'plc' spcl_interfaces_plc                       
    elif [ "$backhaul_iface" = '5G' ]; then
        __repacd_get_spcl_interfaces '5G' spcl_interfaces_5g
    else
        __repacd_get_spcl_interfaces '2.4G' spcl_interfaces_24g
    fi

    __repacd_echo "2g interfaces:$spcl_interfaces_24g, 5g interfaces:$spcl_interfaces_5g" 
    __repacd_echo " plc interfaces:$spcl_interfaces_plc" 

    if [ -n "$spcl_interfaces_5g" ]; then
        for interface in $spcl_interfaces_5g; do
            if [ -f $WIFI_TYPE_BCM ]; then
                iface_type=$(uci get wireless.$interface.type)
                iface_mode=$(uci get wireless.$interface.mode)
                if [ $iface_type = "config" ] || [ $iface_type = "backhaul" -a $iface_mode = "ap" ]; then
                    continue
                fi
                ifname=`brctl show br-$network | grep "$interface.$id"`
            else
                mode=`iwconfig "$interface" 2>&1 | grep "Mode:Managed" `
                ifname=`iwconfig 2>&1 | grep "$interface.$id" | cut -d ' ' -f1`
            fi
            if [ -n "$mode" -a -n "$ifname" ] || [ "$interface_type" = "all" -a -n "$ifname" ]; then
                __repacd_echo "$interface.$id exist, del it."
                __repacd_del_vlan_interface $network "$interface.$id"
                ifconfig $interface.$id down
                [ $id = 2 ] && {
                    #guest network
                    #echo "repacd_$interface.$id-$network" > /dev/console
                    ubus call network.interface."$network" remove_device "{ \"name\": \"$interface.$id\" }"
                }

                brctl delif "br-$network" "$interface.$id"
                vlan_del "$interface" "$id"
                config_changed=1
                __repacd_echo "cmd:ifconfig $interface.$id down; brctl delif br-$network $interface.$id; vlan_del $interface.$id"
            else
                __repacd_echo "mode:$mode != Managerd or $interface.$id does not exist."
            fi
        done
    fi

    if [ -n "$spcl_interfaces_24g" ]; then
        for interface in $spcl_interfaces_24g; do
            if [ -f $WIFI_TYPE_BCM ]; then
                iface_type=$(uci get wireless.$interface.type)
                iface_mode=$(uci get wireless.$interface.mode)
                if [ $iface_type = "config" ] || [ $iface_type = "backhaul" -a $iface_mode = "ap" ]; then
                    continue
                fi
                ifname=`brctl show br-$network | grep "$interface.$id"`
            else
                mode=`iwconfig "$interface" 2>&1 | grep "Mode:Managed" `
                ifname=`iwconfig 2>&1 | grep "$interface.$id" | cut -d ' ' -f1`
            fi
            if [ -n "$mode" -a -n "$ifname" ] || [ "$interface_type" = "all" -a -n "$ifname" ]; then
                __repacd_echo "$interface.$id exist, del it."
                __repacd_del_vlan_interface $network "$interface.$id"
                ifconfig $interface.$id down
                [ $id = 2 ] && {
                    #guest network
                    #echo "repacd_$interface.$id-$network" > /dev/console
                    ubus call network.interface."$network" remove_device "{ \"name\": \"$interface.$id\" }"
                }

                brctl delif "br-$network" "$interface.$id"
                vlan_del "$interface" "$id"
                config_changed=1
                __repacd_echo "cmd:ifconfig $interface.$id down; brctl delif br-$network $interface.$id; vlan_del $interface.$id"
            else
                __repacd_echo "mode:$mode != Managerd or $interface.$id does not exit."
            fi
        done
    fi
    
    if [ -n "$spcl_interfaces_plc" ]; then
        for interface in $spcl_interfaces_plc; do
            ifname=`ifconfig 2>&1 | grep "$interface.$id" | cut -d ' ' -f1`
            if [ -n "$ifname" ]; then
                __repacd_echo "$interface.$id exist, del it."
                __repacd_del_plc_interface $network "$interface.$id"
                ifconfig $interface.$id down
                brctl delif "br-$network" "$interface.$id"
                vlan_del "$interface" "$id"
                config_changed=1
                __repacd_echo "cmd:ifconfig $interface.$id down; brctl delif br-$network $interface.$id; vlan_del $interface.$id"
            else
                __repacd_echo "$interface.$id does not exit."
            fi
        done
    fi    

}

__repacd_del_invalid_vlan_interfaces() {
    local network=$1
    local wifi_iface
    local ifnames
    local disabled
    if [ "$network" = "iptv" ]; then
        config_load iptv_v2
        config_get ifnames info vlanifs
        for iface in $ifnames; do
            if [ -f $WIFI_TYPE_BCM ]; then
                wifi_iface=${iface%.*}
                wifi_iface=${wifi_iface//./}
            else
                wifi_iface=`echo "$iface" | cut -d '.' -f1`
            fi
            config_load wireless
            config_get disabled "$wifi_iface" disabled '1'
            if [ "$disabled" -gt 0 ]; then
                __repacd_echo "__repacd_del_invalid_vlan_interfaces: $wifi_iface is disabled, del it's vlan interface and down it."
                __repacd_del_vlan_interface $network $iface
                ifconfig $iface down
                brctl delif "br-$network" $iface
                tag=$(echo $iface | awk -F . '{print $NF}')
                vlan_del $wifi_iface $tag
                config_changed=1 
                __repacd_echo "cmd:ifconfig $iface down; brctl delif br-$network $iface; vlan_del $iface"
                           
            fi
        done

    elif __repacd_network_exist $network; then
        config_load network
        config_get ifnames "$network" vlanifs
        for iface in $ifnames; do
            if [ -f $WIFI_TYPE_BCM ]; then
                wifi_iface=${iface%.*}
                wifi_iface=${wifi_iface//./}
            else
                wifi_iface=`echo "$iface" | cut -d '.' -f1`
            fi
            config_load wireless
            config_get disabled "$wifi_iface" disabled '1'
            if [ "$disabled" -gt 0 ]; then
                __repacd_echo "__repacd_del_invalid_vlan_interfaces: $wifi_iface is disabled, del it's vlan interface and down it."
                __repacd_del_vlan_interface $network $iface
                ifconfig $iface down
                brctl delif "br-$network" $iface
                tag=$(echo $iface | awk -F . '{print $NF}')
                vlan_del $wifi_iface $tag
                config_changed=1 
                __repacd_echo "cmd:ifconfig $iface down; brctl delif br-$network $iface; vlan_del $iface"
                           
            fi
        done
    fi    
}

__repacd_get_wlan_sta_ifaces() {
    local config="$1"
    local iface disabled mode

    config_get iface "$config" ifname
    config_get disabled "$config" disabled '0'
    config_get mode "$config" mode 'ap'

    if [ -n "$iface" -a "$mode" = "sta" -a "$disabled" -eq 0 ]; then
        if whc_is_5g_vap $config; then
            sta_5g="$iface"
        else
            sta_24g="$iface"
        fi
    fi
}

__repacd_get_wlan_ap_ifaces() {
    local config="$1"
    local iface network disabled mode is5g
    local dev_5g 
    local dev_5g2 

    dev_5g=$(uci -c /etc/profile.d/ get interfaces.radio_5g.name 2>/dev/null)
    dev_5g2=$(uci -c /etc/profile.d/ get interfaces.radio_5g_2.name 2>/dev/null)
    if [ -z "${dev_5g}" ] || [ -z "${dev_5g2}" ]; then
        dev_5g="wifi1"
        dev_5g2="wifi2"
    fi
    config_get iface "$config" ifname
    config_get disabled "$config" disabled '0'
    config_get mode "$config" mode 'ap'
    config_get device "$config" device

    if [ -n "$iface" -a "$mode" = "ap" -a "$disabled" -eq 0 ]; then
        if [ "$device" == "${dev_5g}" ]; then
            ap_5g1="$iface"
        elif [ "$device" == "${dev_5g2}" ]; then
            ap_5g2="$iface"
        fi
    fi
}
  

__repacd_prep_scan() {    
    wifi_type="$1"
    ap_5g1=
    ap_5g2=
    config_load wireless
    config_foreach __repacd_get_wlan_ap_ifaces wifi-iface 
    
    #[ -n "$ap_5g1" ] && iwlist "$ap_5g1" scanning > /tmp/wifi_scan_result_5g
    [ -n "$ap_5g2" ] && {
        if [ "$wifi_type" = "BCM" ]; then
            # 5G scan may scan band1/2/3/4, will take about 4s
            wl -i "$ap_5g2" scan
            sleep 5
            wl -i "$ap_5g2" getscan > /tmp/wifi_scan_result_5g_2
        else
            sleep 2
            iwlist "$ap_5g2" scanning > /tmp/wifi_scan_result_5g_2
        fi
    }
}

# Determine the configured RE mode, not applying any automatic mode
# switching rules.
#
# output: $1 variable in which to place the resolved mode
__repacd_get_config_re_mode() {
    local resolved_mode=$1
    local mode

    config_load 'repacd'
    config_get mode repacd 'ConfigREMode' 'auto'

[32m    eval "$resolved_mode=$mode"[0m
}

# Determine whether the provided mode is an automatic mode.
#
# input: $1 mode: the mode to check
# return: 0 if the mode is an auto mode; otherwise 1
__repacd_is_auto_re_mode() {
    local mode=$1

    if [ "$mode" = 'auto' ]; then
        return 0
    fi

    return 1
}

# Resolve the current mode in which to operate the range extender.
#
# This mode is either the configured mode (if it is set to a specific
# mode), the automatically derived RE mode based on association information,
# or the default range extender mode for use at startup.
#
# output: $1 - the variable into which to place the resolved mode
__repacd_get_re_mode() {
    local resolved_mode=$1
    local mode default_mode

    __repacd_get_config_re_mode config_re_mode

    if __repacd_is_auto_re_mode $config_re_mode; then
        config_get default_mode repacd 'DefaultREMode' 'qwrap'
        config_get mode repacd 'AssocDerivedREMode' $default_mode
    else
        mode=$config_re_mode
    fi

    # Get the Association derived sub-mode. If not derived, say "star".
    config_get resolved_re_submode repacd 'AssocDerivedRESubMode' 'star'

[32m    eval "$resolved_mode=$mode"[0m
}

# Determine if the range extension mode is set to WDS.
#
# return: 0 if the mode is set to WDS; otherwise 1 (meaing QWrap or ExtAP)
__repacd_is_wds_mode() {
    __repacd_get_re_mode resolved_re_mode

    case "$resolved_re_mode" in
        wds|WDS)
            return 0
        ;;

        *)
            return 1
        ;;
    esac
}

# Determine if the range extension mode is set to QWrap.
#
# return: 0 if the mode is set to QWrap; otherwise 1 (meaning WDS or ExtAP)
__repacd_is_qwrap_mode() {
    __repacd_get_re_mode resolved_re_mode
    case "$resolved_re_mode" in
        qwrap|QWRAP)
            return 0
        ;;

        *)
            return 1
    esac
}

# Determine if the range extension mode is set to SON.
# Note that if the hyd init script is missing, this will be considered as
# SON mode disabled.
#
# return: 0 if the mode is set to SON; otherwise 1 (meaing WDS or an
#         interoperable range extension mode)
__repacd_is_son_mode() {
    __repacd_get_re_mode resolved_re_mode
    case "$resolved_re_mode" in
        son|SON)
            return 0
        ;;

        *)
            return 1
        ;;
    esac
}

# Determine if DFS channels are to be blocked even for WDS mode.
#
# return: 0 if DFS channels should not be used; otherwise 1 (meaning they may
#         be used)
__repacd_is_block_dfs() {
    local block_dfs

    config_load 'repacd'
    config_get block_dfs repacd 'BlockDFSChannels' '0'

    if [ "$block_dfs" -gt 0 ]; then
        return 0
    else
        return 1
    fi
}

# Get the configured Rate scaling factor.
# Gives default value in case of configuration miss or invalid value.
#
# output: $1 - rate_scaling_factor
__repacd_get_rate_scaling_factor() {
    local scaling_factor

    config_load 'repacd'
    config_get scaling_factor WiFiLink 'RateScalingFactor' $RE_DEFAULT_RATE_ESTIMATE_SCALING_FACTOR

    # If scaling factor out of limits, return the default value "70".
    if [ "$scaling_factor" -lt '1' \
        -o "$scaling_factor" -gt '100' ]; then
        scaling_factor=$RE_DEFAULT_RATE_ESTIMATE_SCALING_FACTOR
    fi

[32m    eval "$1=$scaling_factor"[0m
}

# Determine if the mode on the interface is a match.
# This does fuzzy matching in that multiple actual modes are said to match
# a given general mode.
#
# input: $1 general_mode: one of 'sta' or 'ap'
# input: $2 cur_mode: the currently configured mode
# return: 0 on a match; otherwise non-zero
__repacd_is_matching_mode() {
    local general_mode=$1
    local cur_mode=$2

    if [ "$general_mode" = 'sta' ]; then
        if [ "$cur_mode" = 'sta' ]; then
            return 0
        else
            return 1
        fi
    else
        if [ "$cur_mode" = 'ap' -o "$cur_mode" = 'wrap' ]; then
            return 0
        else
            return 1
        fi
    fi
}


# Change the configuration on the wifi-device object to match what is desired
# (either QWrap enabled or disabled based on the second argument).
#
# input: $1 config: section to update
# input: $2 1 - enable, 0 - disable
# input-output: $3 change counter
__repacd_config_qwrap_device() {
    local config="$1"
    local mode network
    local changed="$3"

    # @todo This will need to be updated for 3 radio configurations. The
    #       qwrap_enable should be set for the radio with the backhaul and
    #       qwrap_dbdc_enable should be set for the radios with only an AP
    #       interface.
    config_get hwmode "$config" hwmode
    config_get type "$config" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ]; then
	return
    fi

    if whc_is_5g_radio $1; then
        local qwrap_enable
        config_get qwrap_enable "$config" qwrap_enable
        if [ ! "$2" = "$qwrap_enable" ]; then
            uci_set wireless $config qwrap_enable $2
            changed=$((changed + 1))
[32m            eval "$3='$changed'"[0m
            __repacd_echo "Set radio $config to QWrap Enabled=$2"
        fi
    else   # must be 2.4 GHz
        local qwrap_dbdc_enable
        config_get qwrap_dbdc_enable "$config" qwrap_dbdc_enable
        if [ ! "$2" = "$qwrap_dbdc_enable" ]; then
            uci_set wireless $config qwrap_dbdc_enable $2
            changed=$((changed + 1))
[32m            eval "$3='$changed'"[0m
            __repacd_echo "Set radio $config to QWrap DBDC Enabled=$2"
        fi
    fi
}

# Set the option that indicates whether the DBDC repeater feature should be
# enabled or not.
#
# input: $1 config: section to update
# input: $2 1 - enable, 0 - disable
# input-output: $3 change counter
__repacd_config_dbdc_device() {
    local config="$1"
    local changed="$3"

    local dbdc_enable
    config_get hwmode "$config" hwmode
    config_get type "$config" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ]; then
	return
    fi

    config_get dbdc_enable "$config" dbdc_enable
    if [ ! "$2" = "$dbdc_enable" ]; then
        uci_set wireless $config dbdc_enable $2
        changed=$((changed + 1))
[32m        eval "$3='$changed'"[0m
        __repacd_echo "Set radio $config to DBDC Enabled=$2"
    fi
}


# Change the configuration on the wifi-iface object to match what is desired.
# The values provided are determined by the caller based on the desired
# mode of operation (eg. QWrap/ExtAP or not).
#
# input: $1 config: section to update
# input: $2 network: only update if network matches this value
# input: $3 enable_wds: 1 - enable, 0 - disable
# input: $4 qwrap_ap: 1 - enable, 0 - disable
# input: $5 extap: 1 - enable, 0 disable
# input: $6 block_dfs_chan: 1 - block DFS channels, 0 - do not block them
# input: $7 enable_rrm: 1 - enable, 0 disable
# inout: $8 re_scalingfactor: 0 - ignore, 1 to 100 valid for sta
# input-output: $9 change counter
__repacd_config_iface() {
    local config="$1"
    local device mode network enable_wds qwrap_ap extap block_dfs enable_rrm
    local bssid re_scalingfactor
    local num_changes=0
    local changed="$9"

    config_get device "$config" device
    config_get hwmode "$device" hwmode
    config_get type "$device" type

    if [ "$hwmode" = '11ad' ] && [ "$type" = 'mac80211' ] ;then
       return
    fi

    config_get mode "$config" mode
    config_get network "$config" network
    config_get enable_wds "$config" wds
    config_get qwrap_ap "$config" qwrap_ap
    config_get extap "$config" extap
    config_get block_dfs "$config" blockdfschan
    config_get enable_rrm "$config" rrm
    config_get bssid "$config" bssid ''
    config_get re_scalingfactor "$config" re_scalingfactor '0'

    if [ "$2" = "$network" ]; then
        # wireless.iface.wds should not set here for BCM DUT
        if [ ! "$3" = "$enable_wds" ] && [ ! -f $WIFI_TYPE_BCM ]; then
            uci_set wireless $config wds $3
            num_changes=$((num_changes + 1))
            __repacd_echo "Set iface $config to WDS=$3"
        fi

        # These should only be set on AP interfaces.
        if __repacd_is_matching_mode 'ap' $mode; then
            if [ ! "$4" = "$qwrap_ap" ]; then
                uci_set wireless $config qwrap_ap $4
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to QWrapAP=$4"
            fi

            # @todo If there are multiple 5 GHz radios, will need to figure
            #       out which can act as the backhaul.

            # Set the interface into wrap or vanilla AP mode as appropriate
            if whc_is_5g_radio $device; then
                if [ "$4" -gt 0 ]; then
                    if [ ! "$mode" = 'wrap' ]; then
                        uci_set wireless $config mode 'wrap'
                        num_changes=$((num_changes + 1))
                        __repacd_echo "Set iface $config mode to wrap"
                    fi
                else  # WDS or ExtAP mode
                    if [ ! "$mode" = 'ap' ]; then
                        uci_set wireless $config mode 'ap'
                        num_changes=$((num_changes + 1))
                        __repacd_echo "Set iface $config mode to ap"
                    fi
                fi
            fi

            if [ ! "$6" = "$block_dfs" ]; then
                uci_set wireless $config blockdfschan $6
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to BlockDFSChan=$6"
            fi

            if [ ! "$7" = "$enable_rrm" ]; then
                uci_set wireless $config rrm $7
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to RRM=$7"
            fi
        fi

        if [ ! "$5" = "$extap" ]; then
            uci_set wireless $config extap $5
            num_changes=$((num_changes + 1))
            __repacd_echo "Set iface $config to ExtAP=$5"
        fi

        if [ "$daisy_chain" -gt 0 ] && \
            __repacd_is_matching_mode 'sta' $mode; then
            # Check if bssid updated by wifimon/daisychain, needs restart
            if [ "$bssid_updated" -gt 0 ]; then
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to BSSID=$bssid"
            fi

            if [ ! "$8" = "$re_scalingfactor" ]; then
                uci_set wireless $config re_scalingfactor $8
                num_changes=$((num_changes + 1))
                __repacd_echo "Set iface $config to RE_ScalingFactor=$8"
            fi
        fi

        if [ "$num_changes" -gt 0 ]; then
            changed=$((changed + 1))
[32m            eval "$9='$changed'"[0m
        fi
    fi
}

# Switch the device into acting as the CAP (main gateway).
# Also update the range extension mode as necessary.
#
# input: $1 is_cap: whether the device should act as the central
#                   AP or a secondary gateway connected AP
__repacd_config_gwcon_ap_mode() {
    local is_cap=$1
    local wsplcd_mode son_mode
    local rate_scaling_factor=0

    # The WDS, VAP independent, and QWrap AP settings also need to be updated
    # based on the range extension mode.
    local enable_wds enable_rrm enable_qwrap_ap enable_extap
    local block_dfs enable_multi_ap disable_steering=0
    __repacd_get_config_re_mode config_re_mode
    __repacd_get_re_mode resolved_re_mode
    if __repacd_is_auto_re_mode $config_re_mode || __repacd_is_wds_mode || \
       __repacd_is_son_mode; then
        if __repacd_is_auto_re_mode $config_re_mode || \
           __repacd_is_son_mode; then
            __repacd_echo "Using SON mode for GW Connected AP"
            enable_multi_ap=1
        else   # Must be vanilla WDS
            __repacd_echo "Using WDS mode for GW Connected AP"
            enable_multi_ap=0
        fi

        enable_wds=1
        enable_rrm=1
        enable_qwrap_ap=0
        enable_extap=0

        # In WDS/SON modes, we let the OEM customize whether DFS channels
        # should be permitted.
        if __repacd_is_block_dfs; then
            block_dfs=1
        else
            block_dfs=0
        fi

        #wsplcd_enabled=1
    else
        __repacd_echo "Using Non-WDS mode for GW Connected AP"
        enable_wds=0
        enable_multi_ap=0
        enable_rrm=0
        enable_qwrap_ap=0
        enable_extap=0

        # In QWrap/ExtAP mode, DFS channels should always be disallowed (as it
        # does not appear to suppor them currently). This may be able to
        # relaxed in the future.
        block_dfs=1
    fi

    config_load wireless

    # The QWrap parameters should always be set to 0 on the CAP.
    config_foreach __repacd_config_qwrap_device wifi-device \
        0 config_changed

    # Similarly, the DBDC repeater feature should be disabled on the
    # CAP.
    config_foreach __repacd_config_dbdc_device wifi-device \
        0 config_changed

    # Now set up the interfaces in the right way.
    config_foreach __repacd_config_iface wifi-iface \
        $managed_network $enable_wds $enable_qwrap_ap $enable_extap \
        $block_dfs $enable_rrm $rate_scaling_factor config_changed

    uci_commit wireless

    uci_set repacd repacd Role 'CAP'
    uci_commit repacd

    if [ "$is_cap" -gt 0 ]; then
        son_mode='HYROUTER'
    else
        if __repacd_is_son_mode; then
            enable_multi_ap=1   
        fi
        son_mode='HYCLIENT'
    fi

    #__repacd_configure_son $enable_wds $disable_steering $enable_multi_ap \
    #    $son_mode son_changed
}

# Switch the device to act in one of the NonCAP configurations.
# input: $1 disable_ap - whether to disable the AP interfaces
# input: $2 deep_clone - whether to use deep cloning in wsplcd
# input: $3 deep_clone_no_bssid - whether to use deep cloning without BSSID cloning in wsplcd
__repacd_config_noncap_mode() {
    local disable_ap=$1
    local deep_clone=$2
    local deep_clone_no_bssid=$3

    # The WDS and QWrap AP settings also need to be updated based on the
    # range extension mode.
    local enable_wds enable_qwrap_ap enable_extap enable_dbdc_repeater=0
    local block_dfs enable_rrm enable_multi_ap disable_steering=0
    local rate_scaling_factor=$RE_DEFAULT_RATE_ESTIMATE_SCALING_FACTOR
    local disable_24g_sta=1 disable_5g_sta=0
    local disable_24g_ap=$disable_ap disable_5g_ap=$disable_ap
    if __repacd_is_wds_mode || __repacd_is_son_mode; then
        if __repacd_is_wds_mode; then
            __repacd_echo "Using WDS mode for NonCAP"
        else  # Must be SON mode
            __repacd_echo "Using SON mode for NonCAP"
        fi

        enable_wds=1
        enable_qwrap_ap=0
        enable_extap=0

        # Even if we are not operating in fully coordinated steering mode,
        # we should enable RRM for use in the uncoordinated steering
        # environment.
        enable_rrm=1

        # In WDS mode, we let the OEM customize whether DFS channels should
        # be permitted.
        if __repacd_is_block_dfs; then
            block_dfs=1
        else
            block_dfs=0
        fi

        #wsplcd_enabled=1

        __repacd_get_rate_scaling_factor rate_scaling_factor
    else
        enable_wds=0

        # Until steering can be well supported on QWRAP/ExtAP, there is no real
        # need to have RRM enabled.
        enable_rrm=0

        # wsplcd needs WDS in order to work (as it sends/receives using the
        # bridge interface MAC address). Plus, it is not too likely that the
        # main AP will be running an IEEE P1905.1 registrar.
        wsplcd_enabled=0

        if [ "$disable_ap" -eq 0 ]; then
            if __repacd_is_qwrap_mode; then
                __repacd_echo "Using QWrap mode for NonCAP"
                enable_qwrap_ap=1
                enable_extap=0

            else
                __repacd_echo "Using ExtAP mode for NonCAP"
                enable_qwrap_ap=0
                enable_extap=1
            fi

            # In QWrap/ExtAP mode, DFS channels should always be disallowed
            # (as these modes may not support them properly).
            block_dfs=1
        else  # client mode
            if __repacd_is_qwrap_mode; then
                __repacd_echo "Using QWrap mode for NonCAP"
                enable_qwrap_ap=0
                enable_extap=0

                # @todo What mode should be used here? The STA interface is not
                #       even created if it is not in QWRAP or WDS. We could
                #       potentially consider standalone Proxy STA
                #       mode, but we need details on how to configure this.
            else
                __repacd_echo "Using ExtAP mode for NonCAP"
                enable_qwrap_ap=0
                enable_extap=1
            fi

            # We'll rely on the main AP to decide on DFS or not.
            block_dfs=0
        fi
    fi

    if __repacd_is_son_mode; then
        disable_24g_sta=0
        enable_dbdc_repeater=0
        enable_multi_ap=1
    else
        enable_multi_ap=0

        # Although currently in non-SON mode we do not enable both STA
        # interfaces, just in case we do in the future, set this flag. It
        # should make no difference if only one STA interface is active.
        # use TP-LINK link selection algorithm instead 
        #enable_dbdc_repeater=1
    fi

    config_get bssid_updated WiFiLink BSSIDUpdated '0'

    config_load wireless

    # First set the special options for QWRAP and DBDC repeaters.
    config_foreach __repacd_config_qwrap_device \
        wifi-device $enable_qwrap_ap config_changed
    config_foreach __repacd_config_dbdc_device wifi-device \
        $enable_dbdc_repeater config_changed

    config_foreach __repacd_config_iface wifi-iface \
        $managed_network $enable_wds $enable_qwrap_ap $enable_extap \
        $block_dfs $enable_rrm $rate_scaling_factor config_changed

    uci_commit wireless

    uci_set repacd WiFiLink BSSIDUpdated '0'
    uci_set repacd repacd Role 'NonCAP'
    uci_commit repacd


    #__repacd_configure_son $enable_wds $disable_steering $enable_multi_ap \
    #    'HYCLIENT' son_changed
}

# Switch the device into acting as a range extender.
# Also update the range extension mode as necessary.
__repacd_config_re_mode() {
    local disable_ap=0 deep_clone=1 deep_clone_no_bssid=0

    # We do deep cloning without BSSID for daisy chaining.
    [ "$daisy_chain" -gt 0 ] && deep_clone_no_bssid=1

    # TODO - check if this is needed for traffic separation (or maybe use
    # ConfigSta = 0).
    [ "$traffic_separation_enabled" -gt 0 ] && {
        deep_clone=0
        deep_clone_no_bssid=0
    }

    __repacd_config_noncap_mode $disable_ap $deep_clone $deep_clone_no_bssid
}

# Switch the device into acting as a pure client device (no AP interfaces
# enabled).
__repacd_config_client_mode() {
    local disable_ap=1 deep_clone=0
    __repacd_config_noncap_mode $disable_ap $deep_clone 0
}

__repacd_config_plc_root() {
    local dev_type=$1
    local plc_is_root=$2
    local plc_as_eth=$3

    if [ "$dev_type" = 'AP' ]; then
        uci_toggle_state repacd repacd TrafficPlcAsEth '0'
[32m        eval "$4='0'"         [0m

    elif [ "$dev_type" = 'RE' ]; then
        if [ ! "$plc_is_root" = "$plc_as_eth" ]; then
            uci_toggle_state repacd repacd TrafficPlcAsEth "$plc_is_root"     
[32m            eval "$4='$plc_is_root'" [0m
            son_changed=1
        fi
    fi
}

# Restart wsplcd and the Wi-Fi interfaces based on configuration changes.
__repacd_restart_dependencies() {
    if [ "$config_changed" -gt 0 ]; then
        __repacd_echo "__repacd_restart_dependencies: Restarting network stack..."
        whc_network_restart $wifi_cmd
    else
        __repacd_echo "__repacd_restart_dependencies: No changes; not restarting network stack..."
    fi    
}

fix_default_config() {
    local default_enable
    local role
    local groupinfo
    default_enable=$(uci get wifi.default.enable)
    groupinfo="$(cat /tmp/group-info)"
    role=${groupinfo#*role\":\"} && role=${role%%\"*}
    echo "=========Fix default enable ========="  > /dev/console 
    #echo "role:$role" > /dev/console
    #echo "groupinfo:$groupinfo" > /dev/console

    if [ -s /tmp/group-info ] && [ "$role" = "AP" ]; then
        echo "=========FAP has been binded ========="  > /dev/console 
        if [ $default_enable = "1" ]; then
            echo "=========Set wifi.default.enable from 1 to 0 ========="  > /dev/console 
            uci set wifi.default.enable="0"
            uci commit
            saveconfig a
            lua -e 'require("luci.sys.config").save_config_version(0)'
        fi
    fi

}

touch_iptv_bridge() {
    local br
    br=$(brctl show | grep br-iptv)
    if [ -z "$br" ]; then
        brctl addbr br-iptv
        ifconfig br-iptv mtu 1500
        ifconfig br-iptv up
        if [ ! -f $WIFI_TYPE_BCM ]; then
            echo 0 > /sys/devices/virtual/net/br-iptv/bridge/multicast_snooping
        fi
    fi
}

__iptv_check_device_mode() {
    local config="$1"
    local enabled devid
    local role

   config_get enabled "$config" enable
   if [ "$enabled" != "0" ]; then
	config_get devid "$config" device_id
	config_load bind_device_list
	config_get role $devid role
	if [ "$role" = "RE" ]; then
		is_iptv_ap_only="0"
	fi

   fi
}

check_iptv_only_on_ap() {
    is_iptv_ap_only="1"

    config_load iptv_v2
    config_foreach __iptv_check_device_mode ports

    if [ "$is_iptv_ap_only" = "1" ];then
	return 0
    else
	return 1
    fi
}

get_iptv_backhaul() {
    local role
    local groupinfo
    local iptv_enable
    local iptv_type
    local system_mode

    groupinfo="$(cat /tmp/group-info)"
    role=${groupinfo#*role\":\"} && role=${role%%\"*}
    #echo "role:$role" > /dev/console
    config_load iptv_v2
    config_get iptv_enable info enable "0"
    config_get iptv_type info iptv_type "normal"

    check_iptv_only_on_ap

    config_load sysmode
    config_get system_mode sysmode mode "Router"    

    if [ "$system_mode" != "Router" ]; then
[32m        eval "$1='none'"[0m
        return 0
    fi

    if [ "$iptv_enable" = "0" ] && [ "$iptv_type" != "bridge" ]; then
[32m        eval "$1='none'"[0m
        return 0
    fi

    if [ -s /tmp/group-info ] && [ "$role" = "AP" ]; then
	if [ "$is_iptv_ap_only" = "1" ]; then
[32m                eval "$1='none'"[0m
                return 0		
	fi
        if [ "$iptv_type" = "bridge" ]; then
            #if [ "$iptv_status" = "0" ]; then
[32m                eval "$1='wan'"[0m
                return 0
            #else
[32m            #    eval "$1='none'"[0m
            #    return 0
            #fi
        else
[32m            eval "$1='iptv'"[0m
            return 0
        fi
    elif [ -s /tmp/group-info ]; then
[32m        eval "$1='iptv'"[0m
        return 0
    fi

[32m    eval "$1='none'"[0m
    return 0

}


boot() {
    fix_default_config
    { exec /etc/rc.common "$initscript" start; } > /dev/null 2>&1 &
    exit 0
}

add_pre_config_iface(){
    config_load wifi
    config_get pre_ssid preconfig ssid
    config_load wireless
    iface_2G=$(uci -c /etc/profile.d/ get isp_info.pre_config.iface_2G 2>/dev/null)
    iface_5G=$(uci -c /etc/profile.d/ get isp_info.pre_config.iface_5G 2>/dev/null)
    config_get pre_name iface_5g vapname 
    #echo "pre_ssid:$pre_ssid" > /dev/console
    #echo "pre_name:$pre_name" > /dev/console
    if [ -n "$pre_ssid" ] && [ -z "$pre_name" ]; then
        echo "enter add_pre_config_iface" > /dev/console
        pre_ifaces="$iface_2G $iface_5G"
        for i in $pre_ifaces; do
            uci_add wireless wifi-iface $i
            uci_set wireless $i wds '1'
            uci_set wireless $i disabled '1'
            uci_set wireless $i qwrap_ap '0'
            uci_set wireless $i vapname $i
            uci_set wireless $i mode 'ap'
            uci_set wireless $i vap_ind '0'
            uci_set wireless $i blockdfschan '1'
            uci_set wireless $i rrm '1'
            uci_set wireless $i extap '0'
            uci_set wireless $i network 'backhaul'
            uci_set wireless $i athnewind '1'
            uci_set wireless $i repacd_security_unmanaged '1'
            uci_set wireless $i rept_spl '0'
            uci_set wireless $i type 'preconfig'
            uci_set wireless $i rts 'off'
            uci_set wireless $i wpa_group_rekey '0'
            uci_set wireless $i sko_max_xretries '0'
            uci_set wireless $i ssid 'zEQQty0FzIETcEmn'
            uci_set wireless $i hidden '1'
            uci_set wireless $i encryption 'psk2+ccmp'
            uci_set wireless $i key 'nmbIAZVo'
        done
        uci_set wireless $iface_2G device 'wifi0'
        uci_set wireless $iface_5G device 'wifi1'
        uci_commit wireless
    fi
}

# Script entry point: Perform configuration and start the daemon
start() {
    if [ "$1" = "fix_default_config" ]; then
        fix_default_config
    fi
    if [ "$isDcmp" = "yes" ]; then
        add_pre_config_iface
    fi
    local enabled device_type default_vaps cap_mode gwcon_mode
    local mode wifi_type
    local wifi_config_no_changed=1
    local iptv_backhaul
    get_iptv_backhaul iptv_backhaul

    config_changed=0
    config_load 'wifi' 
    config_get eth_vid guest vlan_id 
    config_get guest_vlan_enable guest vlan_enable '0'
    config_get guest_mix guest mix '0'
    config_get guest_isolate guest host_isolation "1"
    #echo "!!debug"
    #echo "$eth_vid" > /dev/console
    __repacd_echo "Start:"

    config_load 'repacd'

    config_get wifi_type repacd WifiType 'none'
    if [ "$wifi_type" = 'BCM' ]; then
        touch $WIFI_TYPE_BCM
		HYFI_BRIDGING_INIT='/etc/init.d/tpbr'
		HYFI_FILTER='tpbr_filter'
    fi

    config_get_bool enabled repacd 'Enable' '0'
    config_get gwcon_mode repacd GatewayConnectedMode 'AP'
    __repacd_echo "GatewayConnectedMode(gwcon_mode): $gwcon_mode"
    config_get traffic_separation_enabled repacd TrafficSeparationEnabled '0'
    __repacd_echo "TrafficSeparationEnabled(traffic_separation_enabled): $traffic_separation_enabled"
    config_get traffic_separation_active repacd TrafficSeparationActive '0'
    config_get traffic_plc_active repacd TrafficPlcActive '0' 
    config_get traffic_plc_is_root repacd TrafficPlcRoot  '0' 
    config_get traffic_plc_as_eth repacd TrafficPlcAsEth '0'   
    config_get daisy_chain WiFiLink DaisyChain '0'
    config_get network_guest repacd NetworkGuest 'guest'
    config_get guest_backhaul_iface repacd NetworkGuestBackhaulInterface '2.4G'
    __repacd_get_config_re_mode config_re_mode

    [ "$enabled" -gt 0 ] || {
        __repacd_echo "it is disabled, exit."
        return 1
    }
	
	if [ ! -f /tmp/wifi_is_cal ]; then
		__repacd_echo "device is not cal"
		return
	fi

    # Grab a lock to prevent any updates from another repacd start().
    whc_wifi_config_lock	
    __repacd_echo "get whc_wifi_config_lock"

    if [ -f /tmp/wifi_set_done ]; then
         __repacd_echo "clear wifi_set_done flag"
	    rm /tmp/wifi_set_done   
    fi

    __repacd_echo "starting WHC auto-configuration"

    # For now, we can only manage a single network.
    config_get managed_network repacd ManagedNetwork 'lan'
    __repacd_echo "Managed network: $managed_network"

    config_get device_type repacd DeviceType 'RE'
    __repacd_echo "Device type: $device_type"

    # disable guest network when RE is connected to AP by Ethernet
    config_load sysmode
    config_get system_mode sysmode mode "Router"    
    __repacd_echo "Sysmode: $system_mode"
    #if [ "$system_mode" = "AP" ] || [ "$device_type" = 'RE' -a "$gwcon_mode" = "AP" ]; then
    #    uci_toggle_state wifi guest enable "0"
    #else
    #    uci_revert_state wifi guest enable     
    #fi    

    if [ "$system_mode" = "Router" ] && [ "$device_type" = "RE" ] && [ "$guest_mix" == "1" ]; then
        uci_toggle_state wifi guest enable "0"        
        __repacd_echo "the guest network version of the device is older, we need disable the guest network."
    else
        uci_revert_state wifi guest enable   
        __repacd_echo "the guest network version of the device is latest, we do nothing(uci_revert_state wifi guest enable)" 
    fi

    if [ "$system_mode" = "Router" ]; then
        uci_toggle_state wifi guest host_isolation "0"        
    else
        local isMobile=$(isMobile 2>/dev/null)
        if [ "$isMobile" = "yes" ]; then
            #[x80-5G] Fix 515575: ap isolation mode cannot work well
           uci_toggle_state wifi guest host_isolation "$guest_isolate"
        else
            uci_revert_state wifi guest host_isolation
        fi
    fi

    if [ "$system_mode" = "Router" ]; then
        if [ -f "/proc/$HYFI_FILTER/full_isolate"  ]; then
            echo "0" > /proc/$HYFI_FILTER/full_isolate
        fi
    else
        if [ -f "/proc/$HYFI_FILTER/full_isolate"  ]; then
            if [ "$guest_isolate" = "1" ]; then
                echo "1" > /proc/$HYFI_FILTER/full_isolate
            else
                echo "0" > /proc/$HYFI_FILTER/full_isolate
            fi
        fi
    fi

    # wifi_config_wireless
    
    wifi_cmd="$(wifi_config_inspect)"
    [ -n "$wifi_cmd" ] && {
        config_changed=1 
        wifi_config_no_changed=0
        __repacd_echo "wifi config change(is different from /var/state/wifi). wifi_cmd:$wifi_cmd"
    }


    # create additional vaps if traffic separation enabled
    if [ "$device_type" = 'RE' -a "$gwcon_mode" != "CAP" ]; then
        if [ "$traffic_separation_enabled" -gt 0 ]; then
            if __repacd_is_auto_re_mode $config_re_mode || \
               __repacd_is_son_mode || __repacd_is_wds_mode; then
                if __repacd_check_additional_network_exist; then
                    uci_set repacd repacd NetworkBackhaul $network_spcl
                    uci_commit repacd
                fi
            fi
        fi
    fi    

    if [ "$device_type" = 'AP' ]; then
        # WAN group not empty; this device will act as CAP regardless of
        # the GatewayConnectedMode setting
        __repacd_config_gwcon_ap_mode 1
    elif [ "$device_type" = 'RE' ]; then
        if [ "$gwcon_mode" = "AP" ]; then
            __repacd_config_gwcon_ap_mode 0
        else
        # WAN group empty or non-existent
        # Switch to range extender mode
            __repacd_config_re_mode
        fi
    else
        # Must be a client device (that can opportunistically act as an RE).
        __repacd_config_client_mode
    fi
  

    #whc_wifi_config_unlock

    __repacd_restart_dependencies

    config_load iptv_v2
    config_get iptv_type info iptv_type "bridge"
    config_get iptv_enable info enable "0" 
    config_get backhaul_id info iptv_backhaul_vid "491"

    config_clear

    touch_iptv_bridge
    [ "$iptv_backhaul" = "none" -o -d /sys/class/net/br-$iptv_backhaul ] && {
	local old_iptv_backhaul_info
	local new_iptv_backhaul_info="$device_type""_""$iptv_enable""_""$iptv_type""_""$backhaul_id""_""$is_iptv_ap_only"
	
	[ -s "$IPTV_BACKHAUL_FILE" ] && old_iptv_backhaul_info=`cat $IPTV_BACKHAUL_FILE`
	if [ "$old_iptv_backhaul_info" != "$new_iptv_backhaul_info" ]; then
		[ -s "$IPTV_BACKHAUL_FILE" ]  && $HYFI_BRIDGING_INIT restart
		rm -rf "$IPTV_BACKHAUL_FILE"
		echo "$new_iptv_backhaul_info" > "$IPTV_BACKHAUL_FILE"
	fi


	
    }
    
    # create vlan interfaces required for traffic separation.
        if __repacd_is_auto_re_mode $config_re_mode || \
           __repacd_is_son_mode || __repacd_is_wds_mode; then
            if [ "$traffic_separation_enabled" -gt 0 ]; then
                if __repacd_check_additional_network_exist; then
                    config_changed=0
                    son_changed=0
                    __repacd_add_vlan_interfaces $managed_network '1' 'wifi'
                    if [[ "$system_mode" != "AP" ]]; then
                        __repacd_add_vlan_interfaces $managed_network '2' 'wifi'

                        __repacd_del_vlan_interfaces "$wan_network" "$iptv_backhaul_id" "wifi" "all"
                        __repacd_del_vlan_interfaces "$iptv_network" "$iptv_backhaul_id" "wifi" "all"
                        if [ "$iptv_backhaul" = "iptv" ]; then
                            __repacd_add_vlan_interfaces "$iptv_network" "$iptv_backhaul_id" "wifi"
                        elif [ "$iptv_backhaul" = "wan" ]; then 
                            __repacd_add_vlan_interfaces "$wan_network" "$iptv_backhaul_id" "wifi"
                        fi
                    fi

                    __repacd_del_invalid_vlan_interfaces $managed_network
                    if [ "$iptv_backhaul" = "iptv" ]; then
                        __repacd_del_invalid_vlan_interfaces $iptv_network
                    elif [ "$iptv_backhaul" = "wan" ]; then
                        __repacd_del_invalid_vlan_interfaces $wan_network
                    fi
                    
                    __repacd_config_plc_root $device_type $traffic_plc_is_root $traffic_plc_as_eth traffic_plc_as_eth 

                    if [ "$traffic_plc_active" -gt 0 -o "$traffic_plc_as_eth" -gt 0 ]; then
                        __repacd_add_vlan_interfaces $managed_network "$plc_backhaul_vid" 'plc'
                        if [[ "$system_mode" != "AP" ]]; then
                            __repacd_add_vlan_interfaces $managed_network "$plc_guest_vid" 'plc'
                            if [ "$iptv_backhaul" = "iptv" ]; then
                                __repacd_add_vlan_interfaces "$iptv_network"  "$plc_iptv_vid" "plc"
                            elif [ "$iptv_backhaul" = "wan" ]; then
                                __repacd_add_vlan_interfaces "$wan_network"  "$plc_iptv_vid" "plc"
                            else
                                __repacd_del_vlan_interfaces "$wan_network" "$plc_iptv_vid" "plc" "all"
                                __repacd_del_vlan_interfaces "$iptv_network" "$plc_iptv_vid" "plc" "all"
                            fi
                        fi
                    else
                        __repacd_del_vlan_interfaces $managed_network "$plc_backhaul_vid" 'plc'
                        if [[ "$system_mode" != "AP" ]]; then
                            __repacd_del_vlan_interfaces $managed_network "$plc_guest_vid" 'plc'
                            __repacd_del_vlan_interfaces "$wan_network" "$plc_iptv_vid" "plc" "all"
                            __repacd_del_vlan_interfaces "$iptv_network" "$plc_iptv_vid" "plc" "all"
                        fi
                    fi
                    
                fi
            fi
        fi
                

    #if [ ! -f /var/run/wifi_led_run_lock ]; then
    #    __repacd_echo "Starting  wifi led Daemon"
	#    touch /var/run/wifi_led_run_lock
    #	    start-stop-daemon -S -x /usr/sbin/wifi_led.sh -b
    #fi

    # for X90: set new getway(wifi config no changed) need to check acsd status
    if [ "$wifi_type" = 'BCM' ] && [ -d /etc/wlan/dhd/ ] && [ "$wifi_config_no_changed" = '1' ]; then
        __repacd_echo "to check acsd status."
        /sbin/bcm_service acsd &
    fi

    # for X68/X20: kill wpa_supplicant when work_mode:RE -> FAP
    local model=$(getfirm MODEL)
    local deco_status=$(cat /tmp/group-info | grep '\"role\":\"AP\"')
    local mem_protect=$(uci get profile.mem_protect.support -c /etc/profile.d)
    if [ "$wifi_type" = 'BCM' ] && [ "$wifi_config_no_changed" = '1' ] && [ -n "$deco_status" ] && ([ -n "$mem_protect" ] && [ "$mem_protect" == "yes" ]); then
        __repacd_echo "to stop wpa_supplicant"
        /sbin/bcm_service wpasupp &
    fi

    touch /tmp/wifi_set_done
    __repacd_echo "set wifi done flag"
    whc_wifi_config_unlock
    __repacd_echo "unlock whc_wifi_config_lock"
    if [ ! -f /tmp/repacd_booted ]; then
        touch /tmp/repacd_booted
        sleep 2
        __repacd_prep_scan $wifi_type
    fi    
}

# Script entry point: Stop the daemon
stop() {
    start-stop-daemon -K -n repacd-run.sh -s SIGTERM >/dev/null
    __repacd_echo "stop repacd-run.sh"
    if [ -f $WSPLCD_INIT ]; then
        $WSPLCD_INIT stop
        __repacd_echo "stop $WSPLCD_INIT"
    fi
}

# Script entry point: Reconfigure and restart the daemon
restart() {
    stop

    config_load 'repacd'
    config_get_bool enabled repacd 'Enable' '0'

    [ "$enabled" -gt 0 ] || {
            return 1
    }

    start
    /etc/init.d/nrd restart
    /etc/init.d/mcsd restart
}

# Force a restart into CAP mode.
#
# This is used when the gateway detection logic detects a gateway on
# ethernet when running in a pure bridge mode.
restart_in_cap_mode() {
    local gwcon_mode
    local device_type
    config_load repacd
    config_get managed_network repacd ManagedNetwork 'lan'
    config_get device_type repacd DeviceType 'RE'
    config_get gwcon_mode repacd GatewayConnectedMode 'AP'
    config_get traffic_separation_enabled repacd TrafficSeparationEnabled '0'
    config_get traffic_separation_active repacd TrafficSeparationActive '0'
    config_get daisy_chain WiFiLink DaisyChain '0'
    config_get network_guest repacd NetworkGuest 'guest'
    __repacd_get_config_re_mode config_re_mode

    __repacd_echo "do restart_in_cap_mode"
    stop

    if [ "$gwcon_mode" = "CAP" ]; then
        # Explicitly being forced into CAP mode while gateway connected.
        # This could be a case where a device is being used as a pure bridge
        # due to another device acting as the gateway.
        __repacd_echo "do __repacd_config_gwcon_ap_mode for cap mode"
        __repacd_config_gwcon_ap_mode 1
    else
        # Operate just as a standalone AP. This assumes there is another
        # device in the network that operates as CAP.
        __repacd_echo "do __repacd_config_gwcon_ap_mode for standalone ap mode"
        __repacd_config_gwcon_ap_mode 0
    fi
 

    __repacd_restart_dependencies
    
    if [ "$gwcon_mode" != "CAP" ]; then
        if __repacd_is_auto_re_mode $config_re_mode || \
           __repacd_is_son_mode || __repacd_is_wds_mode; then
            if [ "$traffic_separation_enabled" -gt 0 ] && \
               [ "$traffic_separation_active" -eq 1 ]; then
                 
                 config_changed=0
                 __repacd_del_vlan_interfaces $managed_network '1' 'both'
                 
            fi
        fi
    fi    


}

# Force a restart into NonCAP mode.
#
# This is used when the gateway detection logic detects that there is no
# longer a gateway connected over ethernet.
restart_in_noncap_mode() {
    local iptv_backhaul
    get_iptv_backhaul iptv_backhaul

    local device_type
    config_load repacd
    config_get managed_network repacd ManagedNetwork 'lan'
    config_get device_type repacd DeviceType 'RE'
    config_get gwcon_mode repacd GatewayConnectedMode 'AP'
    config_get traffic_separation_enabled repacd TrafficSeparationEnabled '0'
    config_get traffic_separation_active repacd TrafficSeparationActive '0'
    config_get traffic_plc_active repacd TrafficPlcActive '0'     
    config_get traffic_plc_is_root repacd TrafficPlcRoot  '0' 
    config_get traffic_plc_as_eth repacd TrafficPlcAsEth '0'     
    config_get daisy_chain WiFiLink DaisyChain '0'
    config_get network_guest repacd NetworkGuest 'guest'
    config_get guest_backhaul_iface repacd NetworkGuestBackhaulInterface '2.4G'
    __repacd_get_config_re_mode config_re_mode

    config_load 'wifi' 
    config_get eth_vid guest vlan_id 
    config_get guest_vlan_enable guest vlan_enable '0'

    config_load sysmode
    config_get system_mode sysmode mode "Router"

    __repacd_echo "do restart_in_noncap_mode, eth vlan id:$eth_vid, guest_vlan_enable:$guest_vlan_enable, sysmode:$system_mode"
    stop

    # Need to resolve the generic NonCAP role to the actual configuration.
    if [ "$device_type" = 'RE' ]; then
        __repacd_echo "do __repacd_config_re_mode for RE mode"
        __repacd_config_re_mode

    else
        __repacd_echo "do __repacd_config_re_mode for normal client mode"
        __repacd_config_client_mode
    fi  

    __repacd_restart_dependencies    

    touch_iptv_bridge

    config_load iptv_v2
    config_get iptv_type info iptv_type "bridge"
    config_get iptv_enable info enable "0" 
    config_clear
    
    # create vlan interfaces required for traffic separation.
    if __repacd_is_auto_re_mode $config_re_mode || \
       __repacd_is_son_mode || __repacd_is_wds_mode; then
        if [ "$traffic_separation_enabled" -gt 0 ]; then
            if __repacd_check_additional_network_exist; then
                    config_changed=0
                    __repacd_add_vlan_interfaces $managed_network '1' 'wifi'
                    if [[ "$system_mode" != "AP" ]]; then
                        __repacd_add_vlan_interfaces $managed_network '2' 'wifi'
                        if [ "$iptv_backhaul" = "iptv" ]; then
                            __repacd_add_vlan_interfaces "$iptv_network" "$iptv_backhaul_id" "wifi"
                        elif [ "$iptv_backhaul" = "wan" ]; then
                            __repacd_add_vlan_interfaces "$wan_network" "$iptv_backhaul_id" "wifi"
                        else
                            __repacd_del_vlan_interfaces "$wan_network" "$iptv_backhaul_id" "wifi" "all"
                            __repacd_del_vlan_interfaces "$iptv_network" "$iptv_backhaul_id" "wifi" "all"
                        fi
                    fi

                    __repacd_config_plc_root $device_type $traffic_plc_is_root $traffic_plc_as_eth traffic_plc_as_eth

                    if [ "$traffic_plc_active" -gt 0 -o "$traffic_plc_as_eth" -gt 0 ]; then
                        __repacd_add_vlan_interfaces $managed_network "$plc_backhaul_vid" 'plc'
                        if [[ "$system_mode" != "AP" ]]; then
                            __repacd_add_vlan_interfaces $managed_network "$plc_guest_vid" 'plc'
                            if [ "$iptv_backhaul" = "iptv" ]; then
                                __repacd_add_vlan_interfaces "$iptv_network"  "$plc_iptv_vid" "plc"
                            elif [ "$iptv_backhaul" = "wan" ]; then
                                __repacd_add_vlan_interfaces "$wan_network"  "$plc_iptv_vid" "plc"
                            else
                                __repacd_del_vlan_interfaces "$wan_network" "$plc_iptv_vid" "plc" "all"
                                __repacd_del_vlan_interfaces "$iptv_network" "$plc_iptv_vid" "plc" "all"
                            fi
                        fi
                    else
                        __repacd_del_vlan_interfaces $managed_network "$plc_backhaul_vid" 'plc'
                        __repacd_del_vlan_interfaces $managed_network "$plc_guest_vid" 'plc'
                        __repacd_del_vlan_interfaces "$wan_network" "$plc_iptv_vid" "plc" "all"
                        __repacd_del_vlan_interfaces "$iptv_network" "$plc_iptv_vid" "plc" "all"
                    fi
            fi
        fi
    fi
}


reload() {

    if [ -f "$IPTV_BACKHAUL_FILE" ]; then
        local old_backhaul_info=`cat $IPTV_BACKHAUL_FILE`

        local device_type
        config_load repacd
        config_get device_type repacd DeviceType 'RE'

        check_iptv_only_on_ap

        config_load iptv_v2
        config_get iptv_type info iptv_type "bridge"
        config_get iptv_enable info enable "0" 
        config_get backhaul_id info iptv_backhaul_vid "491"
        if [ "$old_backhaul_info" = "$device_type""_""$iptv_enable""_""$iptv_type""_""$backhaul_id""_""$is_iptv_ap_only" ]; then
            return 0
        fi
    fi

    restart   
}


