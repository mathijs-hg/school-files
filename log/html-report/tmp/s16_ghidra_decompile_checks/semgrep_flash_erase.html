<br />
<br />
<pre>[</span><span class="orange">*</span>] Binary protection state of </span><span class="orange">flash_erase</span></pre>
<br />
<pre>  	RELRO          CANARY            NX           PIE          RPATH        RUNPATH      SYMBOLS      </pre>
<pre>  	<span class="red">No RELRO</span>       <span class="red">No Canary found</span>   <span class="red">NX disabled</span>  <span class="red">No PIE</span>       <span class="green">No RPATH</span>     <span class="green">No RUNPATH</span>   <span class="red">Symbols</span></pre>
<br />
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/dev_get_major_00401c60.html" title="./semgrep_flash_erase/dev_get_major_00401c60.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/dev_get_major_00401c60.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">21</span> - </span><span class="orange">iVar1 = -(sVar2 + 0x40 &amp; 0xfffffff8)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/dev_read_pos_int_004021f8.html" title="./semgrep_flash_erase/dev_read_pos_int_004021f8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/dev_read_pos_int_004021f8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">22</span> - </span><span class="orange">iVar1 = -(sVar2 + 0x40 &amp; 0xfffffff8)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/sysfs_is_supported_004026a4.html" title="./semgrep_flash_erase/sysfs_is_supported_004026a4.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/sysfs_is_supported_004026a4.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">27</span> - </span><span class="orange">iVar1 = -(sVar2 + 0x18 &amp; 0xfffffff8)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/dev_read_hex_int_00402324.html" title="./semgrep_flash_erase/dev_read_hex_int_00402324.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/dev_read_hex_int_00402324.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">24</span> - </span><span class="orange">iVar1 = -(sVar2 + 0x40 &amp; 0xfffffff8)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/xmalloc_00402a8c.html" title="./semgrep_flash_erase/xmalloc_00402a8c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/xmalloc_00402a8c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">11</span> - </span><span class="orange">pvVar1 = malloc(size)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/main_00400b90.html" title="./semgrep_flash_erase/main_00400b90.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/main_00400b90.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">38</span> - </span><span class="orange">iVar5 = getopt_long(argc,argv,&amp;DAT_00406170,main::lexical_block_0::long_options)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/main_00400b90.html" title="./semgrep_flash_erase/main_00400b90.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/main_00400b90.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">92</span> - </span><span class="orange">desc = libmtd_open()</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/main_00400b90.html" title="./semgrep_flash_erase/main_00400b90.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/main_00400b90.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">97</span> - </span><span class="orange">iVar5 = open64(mtd_device,2)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mtd_dev_present_00403348.html" title="./semgrep_flash_erase/mtd_dev_present_00403348.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mtd_dev_present_00403348.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">15</span> - </span><span class="orange">iVar2 = (int)&amp;local_c0 - (sVar1 + 0x18 &amp; 0xfffffff8)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mtd_get_info_00402c34.html" title="./semgrep_flash_erase/mtd_get_info_00402c34.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mtd_get_info_00402c34.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-insecure-api-scanf-etc</span></pre>
<pre>        Issue description:</pre>
<pre>    A buffer overflow condition exists when a program attempts to put more data in a buffer than it can hold, or when a program attempts to put data in a memory area outside of the boundaries of a buffer.</pre>
<br />
<pre>        </span><span class="green">45</span> - </span><span class="orange">iVar5 = sscanf(pcVar6,"mtd%d%s",&amp;local_128,tmp_buf)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mtd_get_info_00402c34.html" title="./semgrep_flash_erase/mtd_get_info_00402c34.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mtd_get_info_00402c34.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">45</span> - </span><span class="orange">iVar5 = sscanf(pcVar6,"mtd%d%s",&amp;local_128,tmp_buf)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mtd_get_info_00403434.html" title="./semgrep_flash_erase/mtd_get_info_00403434.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mtd_get_info_00403434.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">7</span> - </span><span class="orange">memset(info,0,0x10)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mtd_get_dev_info1_004034b8.html" title="./semgrep_flash_erase/mtd_get_dev_info1_004034b8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mtd_get_dev_info1_004034b8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">18</span> - </span><span class="orange">memset(mtd,0,0x100)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mkpath_00402b6c.html" title="./semgrep_flash_erase/mkpath_00402b6c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mkpath_00402b6c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">12</span> - </span><span class="orange">__dest = (char *)xmalloc(__n + sVar1 + 2)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mkpath_00402b6c.html" title="./semgrep_flash_erase/mkpath_00402b6c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mkpath_00402b6c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">13</span> - </span><span class="orange">memcpy(__dest,path,__n)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mkpath_00402b6c.html" title="./semgrep_flash_erase/mkpath_00402b6c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mkpath_00402b6c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">19</span> - </span><span class="orange">memcpy(__dest_00,name,sVar1 + 1)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/libmtd_open_0040308c.html" title="./semgrep_flash_erase/libmtd_open_0040308c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/libmtd_open_0040308c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">11</span> - </span><span class="orange">lib = (libmtd *)calloc(1,0x34)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/libmtd_open_0040308c.html" title="./semgrep_flash_erase/libmtd_open_0040308c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/libmtd_open_0040308c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">11</span> - </span><span class="orange">lib = (libmtd *)calloc(1,0x34)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_pos_ll_00401ea8.html" title="./semgrep_flash_erase/read_pos_ll_00401ea8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_pos_ll_00401ea8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">13</span> - </span><span class="orange">iVar2 = open64(file,0x80000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_pos_ll_00401ea8.html" title="./semgrep_flash_erase/read_pos_ll_00401ea8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_pos_ll_00401ea8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">15</span> - </span><span class="orange">sVar3 = read(iVar2,buf,0x32)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_pos_ll_00401ea8.html" title="./semgrep_flash_erase/read_pos_ll_00401ea8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_pos_ll_00401ea8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">15</span> - </span><span class="orange">sVar3 = read(iVar2,buf,0x32)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_pos_ll_00401ea8.html" title="./semgrep_flash_erase/read_pos_ll_00401ea8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_pos_ll_00401ea8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">29</span> - </span><span class="orange">iVar4 = sscanf(buf,"%lld</pre>
<pre>    ",value)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_data_004019d0.html" title="./semgrep_flash_erase/read_data_004019d0.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_data_004019d0.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">14</span> - </span><span class="orange">iVar2 = open64(file,0x80000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_data_004019d0.html" title="./semgrep_flash_erase/read_data_004019d0.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_data_004019d0.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">18</span> - </span><span class="orange">sVar3 = read(iVar2,buf,buf_len)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_data_004019d0.html" title="./semgrep_flash_erase/read_data_004019d0.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_data_004019d0.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">18</span> - </span><span class="orange">sVar3 = read(iVar2,buf,buf_len)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_data_004019d0.html" title="./semgrep_flash_erase/read_data_004019d0.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_data_004019d0.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">34</span> - </span><span class="orange">sVar4 = read(iVar2,&amp;tmp,1)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_data_004019d0.html" title="./semgrep_flash_erase/read_data_004019d0.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_data_004019d0.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">34</span> - </span><span class="orange">sVar4 = read(iVar2,&amp;tmp,1)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/legacy_get_dev_info1_00405258.html" title="./semgrep_flash_erase/legacy_get_dev_info1_00405258.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/legacy_get_dev_info1_00405258.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">9</span> - </span><span class="orange">sprintf(node,"/dev/mtd%d",mtd_num,in_a3,&amp;_gp)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_next_00404794.html" title="./semgrep_flash_erase/proc_parse_next_00404794.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_next_00404794.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">17</span> - </span><span class="orange">iVar1 = sscanf(pi-&gt;next,"mtd%d: %llx %x",pi,&amp;pi-&gt;size,&amp;pi-&gt;eb_size)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_next_00404794.html" title="./semgrep_flash_erase/proc_parse_next_00404794.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_next_00404794.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">31</span> - </span><span class="orange">(__n = (int)pvVar2 - (int)__s, iVar1 &lt;= (int)pvVar2 - (int)pcVar4)) {</span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_next_00404794.html" title="./semgrep_flash_erase/proc_parse_next_00404794.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_next_00404794.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">39</span> - </span><span class="orange">memcpy(pi-&gt;name,__s,__n)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" title="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/legacy_get_dev_info_00404aac.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">46</span> - </span><span class="orange">memset(mtd,0,0x100)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" title="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/legacy_get_dev_info_00404aac.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">59</span> - </span><span class="orange">iVar1 = open64(node,0)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" title="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/legacy_get_dev_info_00404aac.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-insecure-api-strcpy-stpcpy-strcat</span></pre>
<pre>        Issue description:</pre>
<pre>    A buffer overflow condition exists when a program attempts to put more data in a buffer than it can hold, or when a program attempts to put data in a memory area outside of the boundaries of a buffer.</pre>
<br />
<pre>        </span><span class="green">205</span> - </span><span class="orange">strcpy(mtd-&gt;name,pi.name)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" title="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/legacy_get_dev_info_00404aac.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">205</span> - </span><span class="orange">strcpy(mtd-&gt;name,pi.name)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_start_00404514.html" title="./semgrep_flash_erase/proc_parse_start_00404514.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_start_00404514.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">12</span> - </span><span class="orange">iVar2 = open64("/proc/mtd",0)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_start_00404514.html" title="./semgrep_flash_erase/proc_parse_start_00404514.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_start_00404514.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">14</span> - </span><span class="orange">pcVar3 = (char *)malloc(0x1000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_start_00404514.html" title="./semgrep_flash_erase/proc_parse_start_00404514.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_start_00404514.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">14</span> - </span><span class="orange">pcVar3 = (char *)malloc(0x1000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_start_00404514.html" title="./semgrep_flash_erase/proc_parse_start_00404514.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_start_00404514.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">26</span> - </span><span class="orange">uVar4 = read(iVar2,pcVar3,0x1000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_start_00404514.html" title="./semgrep_flash_erase/proc_parse_start_00404514.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_start_00404514.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">26</span> - </span><span class="orange">uVar4 = read(iVar2,pcVar3,0x1000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/dev_get_major_00401c60.html" title="./semgrep_flash_erase/dev_get_major_00401c60.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/dev_get_major_00401c60.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">21</span> - </span><span class="orange">iVar1 = -(sVar2 + 0x40 &amp; 0xfffffff8)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/dev_read_hex_int_00402324.html" title="./semgrep_flash_erase/dev_read_hex_int_00402324.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/dev_read_hex_int_00402324.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">24</span> - </span><span class="orange">iVar1 = -(sVar2 + 0x40 &amp; 0xfffffff8)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/dev_read_pos_int_004021f8.html" title="./semgrep_flash_erase/dev_read_pos_int_004021f8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/dev_read_pos_int_004021f8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">22</span> - </span><span class="orange">iVar1 = -(sVar2 + 0x40 &amp; 0xfffffff8)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/legacy_get_dev_info1_00405258.html" title="./semgrep_flash_erase/legacy_get_dev_info1_00405258.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/legacy_get_dev_info1_00405258.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">9</span> - </span><span class="orange">sprintf(node,"/dev/mtd%d",mtd_num,in_a3,&amp;_gp)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" title="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/legacy_get_dev_info_00404aac.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">46</span> - </span><span class="orange">memset(mtd,0,0x100)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" title="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/legacy_get_dev_info_00404aac.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">59</span> - </span><span class="orange">iVar1 = open64(node,0)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" title="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/legacy_get_dev_info_00404aac.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-insecure-api-strcpy-stpcpy-strcat</span></pre>
<pre>        Issue description:</pre>
<pre>    A buffer overflow condition exists when a program attempts to put more data in a buffer than it can hold, or when a program attempts to put data in a memory area outside of the boundaries of a buffer.</pre>
<br />
<pre>        </span><span class="green">205</span> - </span><span class="orange">strcpy(mtd-&gt;name,pi.name)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" title="./semgrep_flash_erase/legacy_get_dev_info_00404aac.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/legacy_get_dev_info_00404aac.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">205</span> - </span><span class="orange">strcpy(mtd-&gt;name,pi.name)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/libmtd_open_0040308c.html" title="./semgrep_flash_erase/libmtd_open_0040308c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/libmtd_open_0040308c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">11</span> - </span><span class="orange">lib = (libmtd *)calloc(1,0x34)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/libmtd_open_0040308c.html" title="./semgrep_flash_erase/libmtd_open_0040308c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/libmtd_open_0040308c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">11</span> - </span><span class="orange">lib = (libmtd *)calloc(1,0x34)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/main_00400b90.html" title="./semgrep_flash_erase/main_00400b90.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/main_00400b90.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">38</span> - </span><span class="orange">iVar5 = getopt_long(argc,argv,&amp;DAT_00406170,main::lexical_block_0::long_options)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/main_00400b90.html" title="./semgrep_flash_erase/main_00400b90.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/main_00400b90.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">92</span> - </span><span class="orange">desc = libmtd_open()</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/main_00400b90.html" title="./semgrep_flash_erase/main_00400b90.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/main_00400b90.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">97</span> - </span><span class="orange">iVar5 = open64(mtd_device,2)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mkpath_00402b6c.html" title="./semgrep_flash_erase/mkpath_00402b6c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mkpath_00402b6c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">12</span> - </span><span class="orange">__dest = (char *)xmalloc(__n + sVar1 + 2)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mkpath_00402b6c.html" title="./semgrep_flash_erase/mkpath_00402b6c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mkpath_00402b6c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">13</span> - </span><span class="orange">memcpy(__dest,path,__n)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mkpath_00402b6c.html" title="./semgrep_flash_erase/mkpath_00402b6c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mkpath_00402b6c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">19</span> - </span><span class="orange">memcpy(__dest_00,name,sVar1 + 1)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mtd_dev_present_00403348.html" title="./semgrep_flash_erase/mtd_dev_present_00403348.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mtd_dev_present_00403348.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">15</span> - </span><span class="orange">iVar2 = (int)&amp;local_c0 - (sVar1 + 0x18 &amp; 0xfffffff8)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mtd_get_dev_info1_004034b8.html" title="./semgrep_flash_erase/mtd_get_dev_info1_004034b8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mtd_get_dev_info1_004034b8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">18</span> - </span><span class="orange">memset(mtd,0,0x100)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mtd_get_info_00402c34.html" title="./semgrep_flash_erase/mtd_get_info_00402c34.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mtd_get_info_00402c34.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-insecure-api-scanf-etc</span></pre>
<pre>        Issue description:</pre>
<pre>    A buffer overflow condition exists when a program attempts to put more data in a buffer than it can hold, or when a program attempts to put data in a memory area outside of the boundaries of a buffer.</pre>
<br />
<pre>        </span><span class="green">45</span> - </span><span class="orange">iVar5 = sscanf(pcVar6,"mtd%d%s",&amp;local_128,tmp_buf)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mtd_get_info_00402c34.html" title="./semgrep_flash_erase/mtd_get_info_00402c34.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mtd_get_info_00402c34.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">45</span> - </span><span class="orange">iVar5 = sscanf(pcVar6,"mtd%d%s",&amp;local_128,tmp_buf)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/mtd_get_info_00403434.html" title="./semgrep_flash_erase/mtd_get_info_00403434.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/mtd_get_info_00403434.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">7</span> - </span><span class="orange">memset(info,0,0x10)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_next_00404794.html" title="./semgrep_flash_erase/proc_parse_next_00404794.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_next_00404794.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">17</span> - </span><span class="orange">iVar1 = sscanf(pi-&gt;next,"mtd%d: %llx %x",pi,&amp;pi-&gt;size,&amp;pi-&gt;eb_size)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_next_00404794.html" title="./semgrep_flash_erase/proc_parse_next_00404794.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_next_00404794.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">31</span> - </span><span class="orange">(__n = (int)pvVar2 - (int)__s, iVar1 &lt;= (int)pvVar2 - (int)pcVar4)) {</span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_next_00404794.html" title="./semgrep_flash_erase/proc_parse_next_00404794.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_next_00404794.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">39</span> - </span><span class="orange">memcpy(pi-&gt;name,__s,__n)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_start_00404514.html" title="./semgrep_flash_erase/proc_parse_start_00404514.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_start_00404514.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">12</span> - </span><span class="orange">iVar2 = open64("/proc/mtd",0)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_start_00404514.html" title="./semgrep_flash_erase/proc_parse_start_00404514.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_start_00404514.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">14</span> - </span><span class="orange">pcVar3 = (char *)malloc(0x1000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_start_00404514.html" title="./semgrep_flash_erase/proc_parse_start_00404514.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_start_00404514.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">14</span> - </span><span class="orange">pcVar3 = (char *)malloc(0x1000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_start_00404514.html" title="./semgrep_flash_erase/proc_parse_start_00404514.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_start_00404514.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">26</span> - </span><span class="orange">uVar4 = read(iVar2,pcVar3,0x1000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/proc_parse_start_00404514.html" title="./semgrep_flash_erase/proc_parse_start_00404514.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/proc_parse_start_00404514.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">26</span> - </span><span class="orange">uVar4 = read(iVar2,pcVar3,0x1000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_data_004019d0.html" title="./semgrep_flash_erase/read_data_004019d0.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_data_004019d0.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">14</span> - </span><span class="orange">iVar2 = open64(file,0x80000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_data_004019d0.html" title="./semgrep_flash_erase/read_data_004019d0.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_data_004019d0.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">18</span> - </span><span class="orange">sVar3 = read(iVar2,buf,buf_len)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_data_004019d0.html" title="./semgrep_flash_erase/read_data_004019d0.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_data_004019d0.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">18</span> - </span><span class="orange">sVar3 = read(iVar2,buf,buf_len)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_data_004019d0.html" title="./semgrep_flash_erase/read_data_004019d0.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_data_004019d0.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">34</span> - </span><span class="orange">sVar4 = read(iVar2,&amp;tmp,1)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_data_004019d0.html" title="./semgrep_flash_erase/read_data_004019d0.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_data_004019d0.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">34</span> - </span><span class="orange">sVar4 = read(iVar2,&amp;tmp,1)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_pos_ll_00401ea8.html" title="./semgrep_flash_erase/read_pos_ll_00401ea8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_pos_ll_00401ea8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">13</span> - </span><span class="orange">iVar2 = open64(file,0x80000)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_pos_ll_00401ea8.html" title="./semgrep_flash_erase/read_pos_ll_00401ea8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_pos_ll_00401ea8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">15</span> - </span><span class="orange">sVar3 = read(iVar2,buf,0x32)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_pos_ll_00401ea8.html" title="./semgrep_flash_erase/read_pos_ll_00401ea8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_pos_ll_00401ea8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">15</span> - </span><span class="orange">sVar3 = read(iVar2,buf,0x32)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/read_pos_ll_00401ea8.html" title="./semgrep_flash_erase/read_pos_ll_00401ea8.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/read_pos_ll_00401ea8.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">29</span> - </span><span class="orange">iVar4 = sscanf(buf,"%lld</pre>
<pre>    ",value)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/sysfs_is_supported_004026a4.html" title="./semgrep_flash_erase/sysfs_is_supported_004026a4.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/sysfs_is_supported_004026a4.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-signed-unsigned-conversion</span></pre>
<pre>        Issue description:</pre>
<pre>    The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.</pre>
<br />
<pre>        </span><span class="green">27</span> - </span><span class="orange">iVar1 = -(sVar2 + 0x18 &amp; 0xfffffff8)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<a class="reference" href="./semgrep_flash_erase/xmalloc_00402a8c.html" title="./semgrep_flash_erase/xmalloc_00402a8c.html" ><pre>[</span><span class="green">+</span>]</span><span class="green"> Identified source function: </span><span class="orange">/logs/s16_ghidra_decompile_checks/haruspex_flash_erase/xmalloc_00402a8c.c</span></span></pre></a>

<pre>        Semgrep rule: </span><span class="orange">external.semgrep-rules-0xdea.c.raptor-interesting-api-calls</span></pre>
<pre>        Issue description:</pre>
<pre>    Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.</pre>
<br />
<pre>        </span><span class="green">11</span> - </span><span class="orange">pvVar1 = malloc(size)</span></span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
